Самая простая для понимания и не самая простая для реализации (в современных реалиях) уязвимость - SQL инъекция.
Часто обзывается просто как SQLi (от SQL injection).
Возникает эта уязвимость там, где вводятся какие-то данные: пароли, комментарии, ID новостей и т.д.

Конкретно для HTTP ее стоит искать в различных полях URI, заголовках и телах запроса.
Это - отправная точка дальнейшего тестирования.
Мы будем изменять нормальные параметры, чтобы узнать как работает сервис и осуществить атаку.

Здесь изменяемые поля прямо в URI

```http
GET https://example.com/news?id=8128 HTTP/1.1
```

```http
POST https://example.com/auth?username=jacob43&password=gfh3oEi HTTP/1.1
```

А здесь - в теле запроса

```http
POST https://example.com/auth HTTP/1.1

Host: example.com
User-Agent: Mozilla/5.0 (U; Linux i540) Gecko/20100101 Firefox/49.3
Accept: application/json
Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.5,en;q=0.3
Accept-Encoding: gzip, deflate, br

```
```json
{username: "jacob43", password: "gfh3oEi"}
```

Когда бекенд плохо написан, данные подставляются прямо в строку запроса без предварительной фильтрации.
Обычные цифирки и буковки навредить запросу не смогут, а специальные символы, которые являются частью SQL - вполне.

Самый простой и банальный пример - запрос авторизации. Вариант <b>плохого</b> кода на бекенде, который выполняет этот запрос.

```python
db.execute('SELECT * FROM users WHERE'
          f'username="{username}" AND password="{password}"')
```

При нормальном запросе переменные `username` и `password` хранят нормальные данные, например `VasyaPupkin` и `HG7F3tfHGr6`.
Эти данные поставятся в код, и запрос к базе данных будет выглядеть так

```

```