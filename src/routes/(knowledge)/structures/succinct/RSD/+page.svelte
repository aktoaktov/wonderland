<script>
  import Title from "$lib/Elements/Title.svelte"
  import Par from "$lib/Markup/Par.svelte"
  import P from "$lib/Markup/P.svelte"
  import Math from "$lib/Math/Math.svelte"
  import Heading from "$lib/Markup/Heading.svelte"
  import Subheading from "$lib/Markup/Subheading.svelte"
</script>

<Title title="Компактные структуры данных"/>

<Par>
<P>
    Пусть <Math m={`z`}/> &mdash; минимальное с точки зрения теории информации количество бит,
    требуемое для хранения информации о данных.
    <b>Компактная структура данных</b> &mdash; структура, хранящая все эти данные,
    и при этом использующая максимально близкое к <Math m={`z`}/> количество бит.
</P>
<P>
    Компактные структуры данных еще называют безызбыточными.
</P>
</Par>

<Heading>Битовые массивы</Heading>

<Par>
<P>

</P>
</Par>

<Heading>Компактные индексируемые словари</Heading>

<Par>
<P>
    <b>Компактный индексируемый словарь</b> или <b>RSD</b> (Rank-Select Dictionary) &mdash;
    битовый массив, поддерживающий две дополнительные операции rank и select.
</P>
<P>
    Сам битовый массив &mdash; массив из <Math m={`n`}/> битов
    (здесь везде индексы, а не номера, поэтому счёт начинается с <Math m={`0`}/>)
</P>
<Math display m={`b_0 \\, b_1 \\, b_2 \\, \\cdots \\, b_{n-2} \\, b_{n-1}`}/>
</Par>

<Par>
<P>
    <b>Rank</b> &mdash; операция подсчёта битов на префиксе.
</P>
<P>
    <Math m={`\\rank_1 (k)`}/> &mdash; количество единичных битов на префиксе длины <Math m={`k`}/>,
    то есть на позициях от <Math m={`0`}/> до <Math m={`k-1`}/>:
</P>
<Math display m={`\\rank_1 (k) \\defeq \\sum_{j=0}^{k-1} b_j`}/>
<P>
    <Math m={`\\rank_0 (k)`}/> &mdash; количество нулевых битов на префиксе длины <Math m={`k`}/>,
    то есть на позициях от <Math m={`0`}/> до <Math m={`k-1`}/>:
</P>
<Math display m={`\\rank_0 (k) \\defeq \\sum_{j=0}^{k-1} (1 - b_j) = k - \\sum_{j=0}^{k-1} b_j = k - \\rank_1 (k)`}/>
<P>
    В операции rank спрятался веса Хемминга <Math m={`\\nu`}/> (количество единичных бит в числе, popcount).
    А именно,
</P>
<Math display
      m={`\\nu \\Bigl( \\bigl( b_0 \\, b_1 \\, b_2 \\, \\dotsm \\, b_{n-2} \\, b_{n-1} \\bigr)_2 \\Bigr) = \\rank_1 (n)`}/>
</Par>

<Par>
<P>
    <b>Select</b> &mdash; операция поиска позиции бита.
</P>
<P>
    <Math m={`\\select_1 (k)`}/> &mdash; позиция <Math m={`k`}/>-го единичного бита
</P>
<Math display m={`\\select_1 (k) \\defeq \\min \\bigl\\{ j : \\rank_1 (j+1) = k \\bigr\\}`}/>
<P>
    <Math m={`\\select_0 (k)`}/> &mdash; позиция <Math m={`k`}/>-го нулевого бита
</P>
<Math display m={`\\select_0 (k) \\defeq \\min \\bigl\\{ j : \\rank_0 (j+1) = k \\bigr\\}`}/>
</Par>


<Subheading>Наивная реализация</Subheading>

<Par>
<P>
    Rank можно считать с помощью префиксных сумм.
    Для этого нужно завести отдельный массив <Math m={`R`}/> длины <Math m={`n`}/>
    и хранить в нём по номеру <Math m={`k`}/> сумму на префиксе длиной <Math m={`k`}/>:
</P>
<Math display m={`R_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{j=0}^{k-1} b_j & \\otherwise}`}/>
<P>
    Теперь операцию rank можно выполнить за <Math m={`O(1)`}/>, а точнее за одно обращение к массиву <Math m={`R`}/>:
</P>
<Math display m={`\\rank_1 (k) = R_k`}/>
</Par>

<Par>
<P>
    Rank &mdash; неубывающая функция, и <Math m={`R`}/> &mdash; неубывающий массив.
    Значит, значение функции select можно найти бинарным поиском по значению rank.
</P>
<P>
    Это вычисление сделает максимум <Math m={`\\lfloor \\log_2 (n+1) \\rfloor + 1`}/> сравнений
    и займёт время <Math m={`O(\\log n)`}/>.
</P>
</Par>

<Par>
<P>
    Важное уточнение по поводу занимаемой массивом <Math m={`R`}/> памяти.
</P>
<P>
    Исходные данные &mdash; битовый массив <Math m={`b`}/>, занимающий в памяти <Math m={`n`}/> бит.
    А в массиве <Math m={`R`}/> мы храним числа,
    и если это обычные <Math m={`64`}/>-битные числа,
    то занимаемая массивом <Math m={`R`}/> память составляет <Math m={`64 \\cdot (n+1)`}/> бит.
    Это слишком много.
</P>
<P>
    Важное замечание, которое позволит сократить память.
    В массиве <Math m={`R`}/> мы храним количества единичных битов на префиксах массива <Math m={`b`}/>,
    а оно не может быть больше <Math m={`n`}/>,
    а значит размер хранимых чисел не превышает <Math m={`\\lfloor \\log_2 n \\rfloor + 1`}/> бит.
</P>
<P>
    То есть, например, если в битовом массиве <Math m={`b`}/> у нас <Math m={`2^{10}-1`}/> бит,
    то для чисел массива <Math m={`R`}/> можно выделять по <Math m={`10`}/> бит, а не по <Math m={`64`}/>.
</P>
<P>
    В итоге занимаемая массивом <Math m={`R`}/> память оказывается
    <Math m={`\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot (n + 1)`}/> бит.
</P>
</Par>

<Par>
<P>
    Можно пойти дальше, и попытаться ещё оптимизировать память.
    <Math m={`R_0 = 0`}/>, значит для хранения этого значения не нужно вообще места,
    <Math m={`R_1 \\le 1`}/>, значит для хранения этого значения нужно не больше <Math m={`1`}/> бита,
    <Math m={`R_2 \\le 2`}/>, значит для хранения этого значения нужно не больше <Math m={`2`}/> битов.
    Продолжая эти рассуждения, получаем, что для хранения <Math m={`R_k`}/>
    нужно не больше <Math m={`\\lfloor \\log_2 k \\rfloor + 1`}/> бит.
    В итоге получаем, что минимальное количество памяти, требуемое для хранения массива <Math m={`R`}/>, равно
</P>
<Math display
      m={`\\sum_{k=1}^n \\bigl( \\lfloor \\log_2 k \\rfloor + 1 \\bigr) = \\sum_{d=1}^{\\lfloor \\log_2 n \\rfloor} d \\cdot 2^{d - 1} + \\bigl( \\lfloor \\log_2 n \\rfloor + 1\\bigr) \\cdot \\bigl( n - 2^{\\lfloor \\log_2 n \\rfloor} + 1 \\bigr) = \\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot (n + 1) - 2^{\\lfloor \\log_2 n \\rfloor + 1} + 1`}/>
<P>
    Результат неплохой: для битового массива <Math m={`b`}/> размером <Math m={`40`}/> МБ
    потребуется дополнительно примерно <Math m={`1`}/> ГБ на массив <Math m={`R`}/>.
</P>
<P>
    Числа на позициях от <Math m={`1`}/> до <Math m={`j`}/> занимают
    <Math m={`\\sum_{k=1}^j \\bigl( \\lfloor \\log_2 k \\rfloor + 1 \\bigr) = \\bigl( \\lfloor \\log_2 j \\rfloor + 1 \\bigr) \\cdot (j + 1) - 2^{\\lfloor \\log_2 j \\rfloor + 1} + 1`}/>
    бит.
    Значит, в таком способе хранения число <Math m={`j`}/> записано в битах на позициях
    с <Math m={`j m - 2^m + 1`}/> по <Math m={`(j+1) \\cdot m - 2^m + 1`}/>,
    где <Math m={`m = \\lfloor \\log_2 j \\rfloor + 1`}/> &mdash; количество бит в числе <Math m={`j`}/>.
</P>
<P>
    Если эта последовательность бит находится в памяти с произвольным доступом,
    то время получения значения <Math m={`R_j`}/> почти константное:
    нам нужно вычислить начало отсчёта и выделить <Math m={`m`}/> бит.
</P>
</Par>


<Par>
<P>
    Мы смогли реализовать битовый массив,
    поддерживающий операции rank за <Math m={`O(1)`}/> и select за <Math m={`O(\\log n)`}/>,
    занимающий <Math m={`O(n \\log n)`}/> бит.
</P>
</Par>

<Subheading>Декомпозиция</Subheading>

<Par>
<P>
    Наивная реализация довольно простая, и это, к сожалению, единственный её плюс.
    Всё ещё проблемой является количество дополнительной информации, требуемое для вычисления rank.
    Меньше бит на числа выделять не получится &mdash; мы и так взяли минимально возможный размер.
    Остаётся только хранить меньше чисел.
</P>
<P>
    Давайте хранить в массиве <Math m={`R`}/> сумму не всех префиксов, а только префиксов чётной длины.
    То есть
</P>
<Math display
      m={`R_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{j = 0}^{2 k - 1} b_j & \\otherwise}
          \\quad\\text{для}~ 0 \\le k \\le \\lfloor n/2 \\rfloor`}/>.
<P>
    Тогда сам rank считается по формуле
</P>
<Math display m={`\\rank_1 (k) = \\cases{R_m & \\if k = 2m \\\\ R_m + b_{k-1} & \\if k = 2m - 1}`}/>
<P>
    То есть мы сократили потребление памяти в <Math m={`2`}/> раза,
    при этом сохранив константную временную сложность вычисления операции rank.
</P>
</Par>

<Par>
<P>
    Развиваем идею. Будем хранить не каждый второй префикс, а каждый <Math m={`\\ell`}/>-й.
    Точнее, мы делим весь исходный массив <Math m={`b`}/> на блоки длиной <Math m={`\\ell`}/>,
    и в массив <Math m={`L`}/> будем сохранять только суммы префиксов до начала каждого блока.
    То есть
</P>
<Math display
      m={`L_k = \\cases{0 & \\if k = 0 \\\\ \\sum_{l = 0}^{k-1} \\sum_{j=0}^{\\ell - 1} b_{l \\ell + j} = \\sum_{j=0}^{k \\ell - 1} b_j  & \\otherwise} \\quad\\text{для}~ 0 \\le k \\le \\lfloor n / \\ell \\rfloor`}/>
<P>
    Для вычисления rank нужно найти префикс и прибавить к нему сумму не более <Math m={`\\ell`}/> слагаемых
</P>
<Math display
      m={`\\rank_1 (k) = L_{\\lfloor k / \\ell \\rfloor} + \\sum_{j = \\lfloor k / \\ell \\rfloor \\cdot \\ell}^k b_j`}/>
<P>
    Получается, что для вычисления операции rank мы совершим не более <Math m={`\\ell`}/> операций сложения.
    Итого, мы можем считать rank за время <Math m={`O(\\ell)`}/> с предподсчётом за время <Math m={`O(n)`}/>.
</P>
<P>
    Для чисел массива <Math m={`L`}/> мы выделяем одинаковое количество бит,
    равное максимальному размеру числа &mdash; <Math m={`\\lfloor \\log_2 n \\rfloor + 1`}/>.
    В итоге мы храним всего
    <Math m={`\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot \\lfloor n / \\ell \\rfloor = O(n \\log n / \\ell)`}/>
    бит.
</P>
<P>
    Компромисса между скоростью и памятью достичь трудно.
    Мы хотим, чтобы rank считался как можно быстрее, а значит <Math m={`\\ell`}/> должно быть как можно меньше.
    А ещё мы хотим, чтобы памяти занималось как можно меньше, значит <Math m={`\\ell`}/> должно быть как можно больше.
    На самом деле компромисс искать не надо.
</P>
</Par>

<Par>
<P>
    На минуту остановимся и подумаем, что вообще у нас получилось.
    Изначально мы пытались ответить на вопрос &laquo;какова сумма первых <Math m={`k`}/> битов?&raquo;
    Теперь, после разделения на блоки, мы пытаемся ответить на вопрос
    &laquo;какова сумма первых <Math m={`k \\bmod \\ell`}/> битов блока?&raquo;
    То есть мы свели исходную задачу к меньшей.
    А эту меньшую задачу можно решить уже отработанным методом &mdash; префиксные суммы.
</P>
<P>
    Давайте для каждого блока с индексом <Math m={`s = \\lfloor k / \\ell \\rfloor`}/> посчитаем префиксные суммы
    и сохраним их в массив <Math m={`R_s`}/>.
    То есть
</P>
<Math display m={`R_s [i] = \\sum_{j = s \\ell}^{s \\ell + i} b_j `}/>
<P>
    И теперь, для вычисления операции rank, надо просто сложить два числа
</P>
<Math display
      m={`\\rank_1 (k) = L \\bigl[ \\lfloor k / \\ell \\rfloor \\bigr] + R_{\\lfloor k / \\ell \\rfloor} [k \\bmod \\ell]`}/>
<P>
    А что по памяти? В массивах <Math m={`R_s`}/> мы храним в сумме <Math m={`n`}/> чисел,
    при этом каждое число не превосходит <Math m={`\\ell`}/>,
    ведь храним мы там количество бит в префиксе блока длины <Math m={`\\ell`}/>.
    Значит, каждое число занимает максимум <Math m={`\\lfloor \\log_2 \\ell \\rfloor + 1`}/> бит,
    а все массивы <Math m={`R_s`}/> занимают <Math m={`n \\cdot \\bigl( \\lfloor \\log_2 \\ell \\rfloor + 1 \\bigr)`}/>
    бит. Итого вся дополнительная память &mdash; память на массив <Math m={`L`}/> и на все массивы <Math m={`R_s`}/>:
</P>
<Math display
      m={`\\bigl( \\lfloor \\log_2 n \\rfloor + 1 \\bigr) \\cdot \\lfloor n / \\ell \\rfloor
          + n \\cdot \\bigl( \\lfloor \\log_2 \\ell \\rfloor + 1 \\bigr)`}/>
<P>
    Минимум достигается при <Math m={`\\ell \\approx \\ln 2n`}/>, и
</P>
<Math display m={`\\min \\space \\approx n \\cdot \\left( \\frac{\\ln \\ln 2n + 1}{\\ln 2} + 1 \\right) = n \\log_2 \\ln n + O(n) = O(n \\log \\log n)`}/>
</Par>


<Subheading>Многоуровневая декомпозиция</Subheading>

<Par>
<P>
    Здесь мы получаем память <Math m={`O(n \\log^* n)`}/>
</P>
</Par>


<Subheading>Четыре русских</Subheading>

<Par>
<P>
    Здесь мы получаем сначала память <Math m={`O(n)`}/>, а потом и <Math m={`o(n)`}/>
</P>
</Par>

<Heading>Разделенные строки</Heading>

<Par>
<P>
    Рассмотрим элементарный, немного нерациональный, слишком простой пример.
</P>
<P>
    Пусть у нас имеется набор строк.
    Этот набор мы превратили в одну строку, соединив исходные строки в одну.
</P>
</Par>