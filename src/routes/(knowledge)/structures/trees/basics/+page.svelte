<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Link from "$lib/Elements/Link.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import Image from "$lib/Elements/Image.svelte"
</script>

<Title title="Деревья"
/>

<Par>
    <P>
        Настало время познакомиться с самыми часто встречающимися нелинейными структурами данных &mdash; деревьями.
    </P>
</Par>

<Definition title="Деревья">
    <P>
        <b>Дерево</b> &mdash; конечное множество узлов <Math m={`T`}/>,
        в котором есть один выделенный узел <Math m={`\\code{root}`}/> &mdash; <b>корень</b>,
        а остальные узлы разделены на <Math m={`m \\ge 0`}/> непересекающихся множеств
        <Math m={`T_1, T_2, \\dotsc, T_m`}/>, которые тоже являются деревьями.
    </P>
    <Math display m={`T \\without \\{\\code{root}\\} = \\bigdjunion_{i=1}^m T_i`}/>

    <P>
        Эти деревья <Math m={`T_1, T_2, \\dotsc, T_m`}/> называются <b>поддеревьями</b> корня <Math m={`\\code{root}`}/>,
        а их количество <Math m={`m`}/> &mdash; <b>степенью</b> корня.
        Обозначается степень корня <Math m={`\\deg \\code{root} \\defeq m`}/>.
    </P>
</Definition>

<Par>
    <P>
        Несмотря на однонаправленность определения, все у нас хорошо.
        Степень существует для любых узлов, и определяется как количество поддеревьев этого узла.
    </P>
    <P>
        Здесь много несостыковок со школьным определением дерева &laquo;дерево &mdash; связный граф без циклов&raquo;.
        В школьном определении нет выделенного корня, да и степень вершины на <Math m={`1`}/> больше...
        Пугаться не стоит, просто это другие деревья.
        Школьные деревья в нашем мире тоже есть, просто называются <b>свободными деревьями</b>.
    </P>
</Par>

<Par>
    <P>
        Из нашего определения выстраивается чёткая иерархия деревьев, их поддеревьев, поддеревьев их поддеревьев и т. д.
        Неимоверно большой соблазн взять и нарисовать линии, соединяющие корень с поддеревьями
        (или с корнями поддеревьев, что одно и то же). Тем самым иерархия показана еще и графически.
    </P>
    <P>
        Теперь мы явно задали наше дерево <Math m={`T`}/> как граф, врешины которого &mdash; все узлы <Math m={`T`}/>,
        а ребро между двумя узлами рисуется, если один из этих узлов является корнем поддерева второго узла.
    </P>
</Par>

<Image alt="Изображение дерева" src=""/>

<Definition title="Типы узлов деревьев">
    <P>
        Если степень узла равна <Math m={`0`}/>, то этот узел называется <b>листом</b> (leaf)
        или терминальным узлом (terminal node).
    </P>
    <P>
        Если степень узла больше <Math m={`0`}/>, то этот узел называется <b>внутренним</b> узлом
        или узлом ветвления (branch node).
    </P>
    <Math display
          m={`\\deg v = 0 \\defequiv \\text{узел}~ v ~\\text{лист} \\qquad \\deg v > 0 \\defequiv \\text{узел}~ v ~\\text{внутренний}`}/>
</Definition>


<Heading>Деревья в памяти компьютера</Heading>

<Par>
    <P>
        Есть два принципиально разных способа хранить деревья в компьютере: безперспективный и малоперспективный.
    </P>
    <P>
        Связан такой скудный рацион с тем, что дерево &mdash; структура нелинейная.
        Как бы мы не пытались линеаризовать связи, у нас ничего не выйдет.
        Или мы потеряем некоторые операции (точнее, сделаем их не такими быстрыми, как хотелось бы),
        или получим жуткий оверхед по времени или по памяти.
    </P>
</Par>

<Par>
    <P>
        Можно пройтись по нашей выстроенной иерархии снизу вверх, храня связь между ребёнком и родителем.
        Тогда в каждом узле просто появится указатель на родителя.
        Если указатель у какой-то вершины на родителя пустой, значит родителя нет и эта вершина &mdash; глобальный корень.
    </P>
</Par>

<Codeblock code={
`struct node:
    node parent
    some additional data`
}/>

