<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Fact from "$lib/Stencils/Blocks/Fact.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
</script>

<Title title="Итераторы"
/>

<Par>
    <P>
        Посмотрим на read-only линейные списки &mdash; такие линейные списки, которые нам нужно только читать.
    </P>
</Par>

<Par>
    <P>
        Пусть нам нужен read-only линейный список, в котором по порядку хранятся натуральные числа
        от <Math m="1"/> до <Math m="10^9"/>.
        Конечно, хранить почти гигабайт данных в каком-нибудь связном списке или массиве не выгодно.
    </P>
    <P>
        Единственная операция, которую мы хотим совершать &mdash; чтение.
        Получается, нам достаточно определить только первый элемент, способ для любого элемента получить следующий
        и какой-то индикатор конца списка.
    </P>
    <P>
        В этом примере первый элемент <Math m="1"/>.
        Для получения элемента, следующего за текущим, нужно к текущему прибавить <Math m="1"/>.
        Конца списка мы достигнем тогда, когда дойдем до элемента <Math m="10^9"/>.
    </P>
</Par>

<Par>
    <P>
        Read-only линейный список не обязательно должен содержать в себе все свои элементы.
    </P>
</Par>

<Definition title="Итератор">
    <P>
        <b>Итератор</b> (iterator) &mdash; изменяемый объект, хранящий свое состояние и
        функция <Code c="next()"/>, которая возвращает или следующий элемент, или <Code c="stop"/>,
        если итератор закончится.
    </P>
    <P>
        <b>Двусторонний</b> итератор (doubly-iterator, next-prev iterator) &mdash;
        изменяемый объект, хранящий свое состояние,
        функция <Code c="next()"/>, которая возвращает следующий элемент
        и функция <Code c="previous()"/>, которая возвращает предыдущий элемент.
    </P>
</Definition>


<Fact title="Итератор и итерируемый объект">
    <P>
        Существует несколько разных и полностью адекватных способов определить всё это.
        Здесь я придерживаюсь классического высокоуровневого определения.
    </P>
    <P>
        Поэтому итератор это итератор, а итерируемый объект (iterable) &mdash; любой объект,
        который можно нормально превратить в итератор.
    </P>
    <P>
        Например любой массив и любая строка являются итерируемыми объектами, но не итераторами.
    </P>
</Fact>


<Heading>Функциональное представление итерируемого</Heading>

<Par>
    <P>
        Любой итератор можно сконструировать с помощью обычной функции и инструкции <Code c="yield"/>.
        Эта операция &laquo;возвращает&raquo; значение из функции, но выполнение функции не прекращается.
        Функция выполняется до тех пор, пока она не закончится или пока не встретится инструкция <Code c="stop"/>.
    </P>
    <P>
        Фактически, итератор не может возвращать значения, ведь в этом слове подразумевается завершение работы функции.
        В разговорной речи для этого используется термин &laquo;йелдить&raquo;.
        Здесь я все-же буду писать слово &laquo;возвращать&raquo;.
    </P>
</Par>

<Par>
    <P>
        Посмотрим на итератор, который возвращает квадраты чисел от <Math m="1"/> до <Math m="100"/>.
    </P>
</Par>

<Codeblock code={
`int current = 1

function next() -> int:
    if current > 100:
        stop
    else:
        to_return = current ** 2
        current += 1
        return to_return`
}/>

<Par>
    <P>
        Этот итератор можно легко записать в функциональной форме
    </P>
</Par>

<Codeblock code={
`iterator squares:
    int current = 1

    while current <= 100:
        yield current ** 2
        current += 1

    stop`
}/>

<Par>
    <P>
        Обращаю внимание на то, что <Code c="squares"/> &mdash; это объект.
        Это не функция, возвращающая итератор.
    </P>
</Par>

<Par>
    <P>
        Теперь, имея на руках итератор, можно по нему итерироваться.
    </P>
    <P>
        Итерирование по итератору &mdash; последовательные получения следующего элемента,
        то есть последовательные вызовы функции <Code c="next()"/>,
        пока однажды мы не получим <Code c="stop"/>.
    </P>
</Par>

<Codeblock code={
`iterator i

do:
    value = i.next()
    ...
while value != stop`
}/>

<Par>
    <P>
        Этот шаблонный код обычно сокращается до привычного всем программистам <Code c="for"/>
    </P>
</Par>

<Codeblock code={
`iterator i

for each value of i:
    ...`
}/>


<Heading>Генераторы</Heading>

<Par>
    <P>
        В чистом виде итераторы нужны не так часто, как функции, создающие итераторы.
    </P>
</Par>

<Definition title="Генератор">
    <P>
        <b>Генератор</b> &mdash; функция, создающая и возвращающая итератор.
    </P>
</Definition>

<Par>
    <P>
        Эта конструкция настолько часто встречается, что для нее не жалко определить свой синтаксис.
    </P>
    <P>
        Итак, <b>чистая</b> функция принимает аргументы <Code c="...arguments"/>, создает итератор и возвращает его.
    </P>
</Par>

<Codeblock code={
`function gen(arguments):
    iterator i:
        ...
    return i`
}/>

<Par>
    <P>
        Выражение <Code c="..."/>, определяющее итератор, пишется сразу в определении генератора. Синтаксис следующий
    </P>
</Par>

<Codeblock code={
`generator gen(arguments):
    ...`
}/>

<Par>
    <P>
        Пусть нам нужно создать итератор, который возвращает все целые числа от <Math m="a"/> до <Math m="b"/>.
    </P>
</Par>

<Codeblock code={
`generator range(int a, int b) -> int:
    int i = a
    while i <= b:
        yield i
        i += 1
    stop`
}/>

<Par>
    <P>
        Получается, что огрызки кода <Code c="for i = a; i <= b; i++"/> и <Code c="for i of range(a, b)"/> имеют
        абсолютно одинаковый смысл и могут друг друга заменять без потери функционала.
    </P>
    <P>
        Важно понимать, что вариант с использованием генератора сильно дольше.
        Там создаются новые локальные переменные, в стек кладется еще одна функция, внутри происходит <Math m="b-a+2"/>
        высокоуровневых вызовов и еще куча другого оверхеда.
    </P>
</Par>


<Heading>Итераторы и Python</Heading>

<Par>
    <P>
        В питоне есть только итераторы.
        Питоновская конструкция <Code language="python" c="for i in iterable"/> эквивалентна нашей
        конструкции <Code c="for each i of iterable"/>.
    </P>
</Par>