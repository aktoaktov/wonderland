<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import EnumList from "$lib/List/EnumList.svelte"
    import ListItem from "$lib/List/ListItem.svelte"
    import BulletList from "$lib/List/BulletList.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Math from "$lib/Math/Math.svelte"
</script>

<Title title="Кеши"
/>

<Par>
    <P>
        Данных всегда очень много. Из-за этого часто проблемным становится быстрый и эффективный доступ к данным.
        В идеальном мире быстрый доступ к данным организовать невозможно, потому что все данные одинаково нужны.
        Но наш мир не идеален. И мы можем этой неидеальностью воспользоваться.
    </P>
    <P>
        Неидеальность выражается в неоднородности требований данных. Какие-то данные нужны чаще. а какие-то реже.
        Рядового пользователя будет гораздо чаще волновать вопрос о сегодняшней погоде,
        нежели вопрос о средней длине летучей мыши.
        Ключ к повышению производительности в том, что ответы на частые вопросы можно сразу получить и запомнить.
    </P>
</Par>

<Par>
    <P>
        Представим работу справочного агенства.
        Есть большая книга с городскими заведениями, для каждого заведения есть базовая информация: название и описание.
        Нам поступают запросы &laquo;а что это за заведение?&raquo; Мы должны отвечать.
    </P>
    <P>
        Когда нам поступил какой-то запрос, мы начинаем искать в этой большой книге нужную информацию.
        Для простоты представим, что данные в книге не адаптированы под поиск и находятся там хаотично.
    </P>
    <P>
        Если нам очень часто поступает запрос про заведение &laquo;Рога и копыта&raquo; мы просто выучим описание.
        Теперь, когда к нам очередной клиент обратится с таким запросом, мы просто дадим ему ответ из памяти,
        не совершая при этом дорогую и долгую операцию поиска в книге.
    </P>
    <P>
        Здесь наш мозг повел себя как кеш &mdash; относительно небольшое хранилище с быстрым доступом к данным.
    </P>
</Par>

<Definition title="Кеширование и кеш">
    <P>
        <b>Кеширование</b> &mdash; это метод оптимизации доступа к данным,
        при котором часто используемая информация сохраняется в быстром хранилище &mdash; <b>кеше</b>
        для уменьшения времени обработки запросов и снижения нагрузки на медленные источники данных.
    </P>
</Definition>

<Par>
    <P>
        Понятие достаточно абстрактное, и это не с проста.
        Типов хранилищ очень много, и для каждого есть какие-то специфичные условия использования.
        Когда мы хотим сделать наиболее эффективную программу или систему, все эти нюансы всплывают сразу же.
    </P>
    <P>
        Итак, зачем вообще нужно кешировать?
    </P>
</Par>

<BulletList>
    <ListItem>
        <P>
            Ускорение доступа к данным.
            Если мы поместим часто используемые данные в быстрое хранилище, общее время доступа к данным увеличится.
            Важно, что это преимущество относится только к io-bound нагрузке.
        </P>
    </ListItem>
    <ListItem>
        <P>
            Снижение нагрузки на хранилище.
            Если какие-то запросы мы будем обрабатывать вне хранилища, то нагрузка на само хранилище уменьшается.
        </P>
    </ListItem>
</BulletList>

<Par>
    <P>
        Сам кеш (пока абстрактный) имеет ассоциативную структуру.
    </P>
</Par>


<Heading>Hit ratio</Heading>

<Par>
    <P>
        Измерять эффективность кеша в общем случае сложно.
        Обусловлена эта сложность тем, что реальные запросы слишком неоднородны.
        Однако, можно ввести интуитивно понятную оценку &mdash; частота &laquo;попаданий&raquo;.
    </P>
    <P>
        Если в какой-то серии запросов результирующие данные оказались в кеше большое количество раз,
        значит кеш хороший, а если маленькое количество раз, то кеш плохой.
        Формально эффективность можно измерить характеристикой hit ratio.
    </P>
</Par>

<Definition title="Hit ratio">
    <P>
        <b>Hit ratio</b> или <b>коэффициент попаданий</b> &mdash; средняя доля запросов, обслуженных кешем.
    </P>
    <Math display m={`\\mathrm{hit~ratio} = \\frac{\\text{число попаданий в кеш}}{\\text{общее число запросов}}`}/>
</Definition>