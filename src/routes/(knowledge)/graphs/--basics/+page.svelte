<script>
    import Heading from "$lib/Markup/Heading.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import Math from "$lib/Math/Math.svelte"
</script>

<Definition title="Граф">
    <P>
        <b>Граф</b> &mdash; пара множеств <Math m="(V, E)"/>, где <Math m="E \subset V^2"/> (здесь тонкий момент).
    </P>
    <P>
        Множество <Math m="V"/> называется <b>множеством вершин</b>,
        а множество <Math m="E"/> называется <b>множеством ребер</b>.<br/>
        Соответственно, <b>ребром</b> называется пара вершин <Math m="(v, u) \in E"/>, которое будет коротко
        записываться <Math m="uv"/>.
    </P>
</Definition>

<Par>
<P>
    Пока ребро из <Math m="u"/> в <Math m="v"/> может быть только одно. Графы, в которых <Math m="E"/> является
    мультимножеством, то есть <Math m="E"/> может содержать несколько одинаковых элементов, называются
    <b>мультиграфами</b>.
    С ними мы познакомимся позднее.
</P>
<P>
    Ребро <Math m="vv"/> из вершины в себя же называется <Math m="петлёй"/>. Графы, содержащие петли, называются <b>псевдографами</b>.
</P>
<P>
    Пока ребра имеют направления: ребро <Math m="uv"/> начинается в вершине <Math m="u"/> и заканчивается в <Math
        m="v"/>.
    Графы, в которых ребра имеют направление, называются <b>ориентированными</b> или просто <b>орграфами</b>.
</P>
<P>
    Примерно в половине случаев направление ребер нас не интересует.
    В этом случае <Math m="E"/> задается как множество неупорядоченных пар вершин.
    Графы, в которых направление ребер не различимо, называются <b>простыми</b>.
</P>
<P>
    Простые графы и орграфы со свойством <Math m="uv \in E \Harr vu \in E"/> &mdash; разные объекты!
    В таких орграфах ребер в два раза больше, чем в простых графах.
</P>
</Par>

<Par>
<P>
    Разберемся с жаргоном. Пусть <Math m="e = uv"/> &mdash; ребро графа <Math m="G = (V, E)"/>.
</P>
<P>
    Ребро <Math m="e"/> соединяет вершину <Math m="u"/> с вершиной <Math m="u"/>.
</P>
<P>
    Две вершины, которые соединены одним ребром, называются <b>смежными</b>.
    Также два ребра, имеющие общий конец, называются <b>смежными</b>.
    Если <Math m="v"/> &mdash; конец ребра <Math m="e"/>, то <Math m="v"/> и <Math m="e"/> <b>инцидентны</b>.
</P>
</Par>

<Par>
<P>Графы можно рисовать на плоскости (а можно и в любом другом пространстве).</P>
<P>
    Точками можно изобразить множество вершин <Math m="V"/>, а линиями, соединяющими некоторые точки-вершины,
    множество ребер <Math m="E"/>.
    Эти линии чаще всего отрезки, но вообще могут быть какими угодно. Лишь бы рисунок выглядел нормально.
</P>
<P>
    В случае орграфов каждая линия рисуется со стрелкой на конце &mdash; так показывается направление.
</P>
</Par>

<Heading>Операции над графами</Heading>

<Par>
<P>
    Над графами можно выполнять операции: рисовать и стирать ребра, добавлять вершины и так далее.
</P>
</Par>

<Definition title="Объединение и пересечение графов">
    <P>
        Пусть <Math m="G_1 = (V_1, E_1)"/> и <Math m="G_2 = (V_2, E_2)"/> &mdash; два графа.
    </P>
    <P>
        Их <b>объединением</b> называется граф <Math m="G_1 \union G_2"/> с множеством вершин <Math m="V_1 \union V_2"/>
        и множеством ребер <Math m="E_1 \union E_2"/>.
    </P>
</Definition>

<Definition title="Удаление ребер и вершин">
    <P>
        Возьмем граф <Math m="G = (V, E)"/>.
        Пусть <Math m="R \subset V \union E"/> &mdash; какое-то множество вершин и ребер, подлежащих удалению.
    </P>
    <P>
        <Math m="G - R"/> &mdash; граф, получающийся из графа <Math m="G"/> удалением всех вершин и ребер из
        выбранного множества <Math m="R"/>.
        Вместе с вершинами из графа удаляются и все ребра, им инцидентные.
    </P>
    <P>
        Распишем формально. Пусть мы хотим удалить вершины <Math m="V_R"/> и ребра <Math m="E_R"/>. Тогда <Math
            m="R = V_R \union E_R"/>.
    </P>
    <Math display
          m={`G-R \\defeq \\Big( V \\without V_R ,\\; E \\without E_R \\without \\{e \\in E : e ~\\text{инцидентно какой-то вершине из}~ V_R \\} \\Big)`}/>
</Definition>

<Par>
<P>
    Пусть <Math m="x \in V \union E"/> &mdash; вершина или ребро, которое мы хотим удалить.
    Для экономии места и уменьшения визуального шума вместо <Math m={`G - \\{x\\}`}/> пишут <Math m="G - x"/>.
</P>
</Par>

<Definition title="Добавление ребра">
    <P>
        Возьмем граф <Math m="G = (V, E)"/>.
        Пусть <Math m="u, v \in V"/> и <Math m="e = xy"/> &mdash; какое-то ребро,
        которое может и не лежать в <Math m="E"/>.
    </P>
    <P>
        <Math m="G + e"/> &mdash; граф, получающийся из графа <Math m="G"/>
        добавлением ребра <Math m="e"/>. Формально,
    </P>
    <Math display m={`G+e = \\big( V, E \\union \\{e\\} \\big)`}/>
</Definition>

<Par>
<P>Теперь мы умеем добавлять и удалять ребра, а также удалять вершины. Добавлять вершины просто так не выйдет
    &mdash; нам нужна дополнительная информация о ребрах, инцидентных этой вершине.</P>
<P>
    Вообще говоря, в добавлении вершины заложено гораздо больше информации, чем в операции <Math m="V \union v"/>.
    Поэтому особо добавление вершины не выделяют.
</P>
</Par>

<Definition title="Стягивание ребра">
    <P>
        Возьмем граф <Math m="G = (V, E)"/>.
        Пусть <Math m="e = xy"/> &mdash; какое-то ребро графа <Math m="G"/>.
    </P>
    <P>
        <Math m="G \cdot e"/> &mdash; граф, получающийся в результате стягивания ребра <Math m="e"/>.
    </P>
    <P>
        К графу <Math m="G - x - y"/> мы добавляем вершину <Math m="w"/>.
        Новая вершина <Math m="w"/> смежна со всеми вершинами <Math m="G"/>,
        которые смежны с <Math m="x"/> или с <Math m="y"/>.
    </P>
    <P>
        Такая вершина <Math m="w"/> будет далее обозначаться <Math m="x \cdot y"/>.
    </P>
</Definition>