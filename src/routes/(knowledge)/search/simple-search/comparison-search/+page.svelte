<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Link from "$lib/Elements/Link.svelte"
    import EnumList from "$lib/List/EnumList.svelte"
    import ListItem from "$lib/List/ListItem.svelte"
    import Image from "$lib/Elements/Image.svelte"

    import imageBinarySearchDecisionTree from './binary-search-decision-tree.svg'
    import Fact from "$lib/Stencils/Blocks/Fact.svelte"
</script>

<Title title="Поиск сравнениями"
/>

<Par>
    <P>
        Давайте представим, что мы ищем слово в словаре.
        Можно, конечно, воспользоваться
        <Link to="/search/simple-search/sequential-search">алгоритмом последовательного поиска</Link>,
        переворачивать страницу за страницей, начав с самой первой.
        Но, кажется, есть вариант получше.
    </P>
    <P>
        В словарях все слова упорядочены. Можно воспользоваться этим свойством словаря.
        Вот пусть нам надо найти слово &laquo;мямлик&raquo;.
        Откроем словарь посередине, и посмотрим на первое слово на странице.
        Оно начинается на букву &laquo;Н&raquo;, которая идет после буквы &laquo;Н&raquo; значит вторая, нижняя половина
        нам не нужна.
        Продолжаем поиск в первой, верхней половине.
        Снова разполовиниваем половину, и смотрим на первую букву первого слова. Это буква &laquo;К&raquo;.
        Теперь нужно отбросить уже первую половину половины, и оставить вторую половину половины.
    </P>
    <P>
        Продолжаем этот процесс, смотрим на вторую букву слова, мы находимся внутри блока слов на букву &laquo;М&raquo;,
        на третью и так далее, пока, наконец, не найдем наше слово.
    </P>
    <P>
        Вообще, есь этот процесс описывался довольно долго, особенно по сравнению очень коротким описанием
        наивного алгоритма &laquo;перебирай по порядку&raquo;.
        Но сейчас мы формализуем это наше действо, проанализируем алгоритм и поймем, что он очень эффективный.
    </P>
</Par>

<Par>
    <P>
        У нас есть массив упорядоченных ключей <Math m={`K_1, K_2, K_3, \\dotsc, K_{n-1}, K_n`}/>.
    </P>
    <Math display m={`K_1 < K_2 < K_3 < \\dotsb < K_{n-1} < K_n`}/>
    <P>
        Я хочу найти в этом массиве номер ключа <Math m={`K`}/>,
        то есть такое <Math m={`j`}/>, что <Math m={`K_j = K`}/>.
    </P>
</Par>

<Par>
    <P>
        Допустим, я сейчас нахожусь на позиции <Math m={`i`}/> и смотрю на ключ <Math m={`K_i`}/>.
        Я сравниваю этот ключ <Math m={`K_i`}/> с искомым ключом <Math m={`K`}/>. У меня три варианта:
    </P>

    <EnumList>
        <ListItem><Math m={`K_i < K`}/>. Все записи, меньшие <Math m={`i`}/>, мне не подходят.</ListItem>
        <ListItem><Math m={`K_i = K`}/>. Ура, я нашел ключ!</ListItem>
        <ListItem><Math m={`K_i > K`}/>. Все записи, бo&#x301;льшие <Math m={`i`}/>, мне не подходят.</ListItem>
    </EnumList>

    <P>
        Этот алгоритм называется <b>бинарным поиском</b>.
        Слово &laquo;бинарный&raquo; здесь присутствует потому, что мы каждый раз делим область поиска пополам.
    </P>
</Par>


<Par>
    <P>
        Перед тем, как превратить наше рукомахание в рабочий код, надо провести некоторые манипуляции.
    </P>
    <P>
        Для начала надо завести переменные <Code c="left"/> и <Code c="right"/>, показывающие границы поиска.
        В самом начале <Math m={`\\code{left} = 0`}/>, а <Math m={`\\code{right} = n - 1`}/>.
        Серединный элемент будем постоянно выбирать как <Math
            m={`\\code{middle} = \\lfloor (\\code{left} + \\code{right}) / 2 \\rfloor`}/>, и на основе значения <Math
            m={`K_{\\code{middle}}`}/> будем менять или правую границу, или левую.
    </P>
    <P>
        Все действия будем делать до тех пор, пока в границе поиска не останется один элемент.
        В этом случае мы просто проверим, совпадает ли он с нашей целью.
    </P>
</Par>

<Codeblock code={
`function binary_search(sequence a, target) -> int:
    int left = 0
    int right = length(a) - 1

    while left <= right:
        int middle = (left + right) / 2

        if a[middle] == target:
            return middle
        else if a[middle] < target:
            left = middle + 1
        else:
            right = middle - 1

    return not found`
}/>

<Par>
    <P>
        Область поиска мы каждую итерацию делим пополам.
        Получается, что временная сложность алгоритма <Math m={`O(\\log n)`}/>.
    </P>
</Par>


<Subheading>Анализ алгоритма</Subheading>

<Par>
    <P>
        Давайте поподробнее проанализируем алгоритм и его время работы.
    </P>
    <P>
        Для наглядности изобразим всю процедуру в виде дерева принятия решений
        для массива длины <Math m={`15`}/>.
    </P>
</Par>

<Image src={imageBinarySearchDecisionTree}/>

<Par>
    <P>
        Начинаем мы с самой верхушки дерева.
        Каждую итерацию мы сравниваем искомое значение <Math m={`K`}/> со значением
        в вершине, и выбираем, куда поти: вправо или влево.
        Дерево решений построено так, что левое поддерево каждой вершины меньше значения в этой вершине,
        а правое поддерево больше.
    </P>
    <P>
        Количество уровней в дереве решений <Math m={`\\lfloor \\log_2 n \\rfloor + 1`}/>.
        Каждую итерацию мы спускаемся вниз ровно на <Math m={`1`}/> уровень.
    </P>
    <P>
        Эффективность алгоритма оценивается количеством сравнений <Math m={`C`}/>.
        Получается, что при <Math m={`2^{k-1} \\le n < 2^k`}/> алгоритм требует
        минимум <Math m={`1`}/> и максимум <Math m={`k`}/> сравнений.
    </P>
</Par>

<Fact title="Распределение аргументов поиска">
    <P>
        Структура массива (и, как следствие, дерева решений) у нас фиксированная.
        Поэтому никакие предположения о распределении аргументов поиска не дадут нам совершенно никакой пользы.
    </P>
    <P>
        Единственное, что нам остается делать &mdash; смотреть на ситуацию с максимальной энтропией.
    </P>
</Fact>

<Par>
    <P>
        Оценим среднее количество сравнений, предположив равномерное распределение аргументов поиска.
        Поиск может закончиться успешно или неудачно.
        Пусть <Math m={`C`}/> &mdash; количество сравнений при успешном поиске,
        а <Math m={`C'`}/> &mdash; количество сравнений при неудачном поиске.
    </P>
    <P>
        При расчете количества сравнений в неудачном поиске мы суммируем глубину несуществующих фиктивных листьев,
        то есть &laquo;пустых&raquo; мест, куда попадает неудачный поиск. Получаем соотношения
    </P>
    <Math display m={`\\expect C = 1 + \\frac{1}{n} \\sum_{v} \\depth v \\quad\\text{и}\\quad
    \\expect C' = \\frac{1}{n+1} \\sum_{v} \\depth v + 2n`}/>
    <P>
        Ну и можно вывести интересную связь между успешным и неудачном поиском
    </P>
    <Math display m={`\\expect C = \\left(1 + \\frac{1}{n}\\right) \\cdot \\expect C' - 1`}/>
</Par>

<Par>
    <P>
        Глубина дерева решений <Math m={`\\lfloor \\log_2 n \\rfloor`}/>.
        При этом в дереве решений заполнены все уровни, кроме, возможно, последнего.
        На всех уровнях, кроме последнего, всего <Math m={`2^{\\lfloor \\log_2 n \\rfloor} - 1`}/> элементов.
        На последнем уровне <Math m={`n - 2^{\\lfloor \\log_2 n \\rfloor} + 1`}/> элементов.
    </P>
    <P>
        Для подсчета средней глубины элементов воспользуемся формулой
    </P>
    <Math display
          m={`\\expect(\\text{глубина элемента}) = \\frac{1}{n} \\Bigg( \\sum_{d=0}^{\\lfloor \\log_2 n \\rfloor - 1} d \\cdot 2^d + \\lfloor \\log_2 n \\rfloor \\cdot \\big( n - 2^{\\lfloor \\log_2 n \\rfloor} + 1 \\big) \\Bigg)`}/>

    <P>
        Подставляем это в формулу <Math m={`\\expect C = 1 + \\expect(\\text{грубина элемента})`}/>,
        считаем и получаем
    </P>
    <Math display
          m={`\\expect C = \\lfloor \\log_2 n \\rfloor \\cdot \\left( 1 + \\frac{1}{n} \\right) - \\frac{2^{\\lfloor \\log_2 n \\rfloor}}{n} + \\frac{2}{n} + 1 = \\log_2 n + O \\left( \\frac{\\log n}{n} \\right)`}/>
</Par>

<Fact title="Внимание, ловушка!">
    <P>
        Полученное значение может немного сбить с толку. Но все хорошо.
    </P>
    <P>
        Максимальная оценка количества сравнений &mdash; количество уровней в дереве,
        <Math m={`\\max C = \\lfloor \\log_2 n \\rfloor + 1`}/>.
        А <Math m={`\\expect C = \\log_2 n + O \\big( \\log n / n \\big)`}/>,
        что где-то на <Math m={`1`}/> меньше.
    </P>
</Fact>