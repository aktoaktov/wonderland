<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Statement from "$lib/Stencils/Blocks/Statement.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Math from "$lib/Math/Math.svelte"
    import BulletList from "$lib/List/BulletList.svelte"
    import ListItem from "$lib/List/ListItem.svelte"
</script>

<Title title="B-деревья"
/>

<Par>
    <P>
        Метода поиска с помощью деревьев больше подходят для задачи внутреннего поиска,
        когда все данные хранятся в оперативной памяти, и нам почти ничего не стоит обращаться к ним много раз.
        Решение задачи внешнего поиска, когда данные хранятся на внешнем накопителе с дорогим доступом,
        требует чуть-чуть иных подходов.
    </P>
    <P>
        Древовидные структуры и деревья всё еще удобны и для внешнего поиска.
        Надо только выбрать способ правильно представить дерева
        и максимально эффективно использовать оперативную память.
    </P>
    <P>
        Давайте рассмотрим довольно простую идею,
        которая открывает нам практически безграничные просторы внешнего поиска.
        Место нашего поиска буду дальше называть диском.
        Вот пусть для поиска в диске мы используем бинарное дерево. Записей у нас <Math m={`1\\,000\\,000`}/>.
        Если наше дерево идеально сбалансировано,
        то при поиске нам понадобится сделать <Math m={`\\log_2 1\\,000\\,000 \\approx 20`}/> обращений к диску.
    </P>
    <P>
        Разделим наши данные в древесной структуре на страницы фиксированного размера, как на рисунке.
        Будем из диска запрашивать не по одному значению, а сразу по страницам.
        Тогда наш поиск ускорится в <Math m={`\\log_2 (\\text{высота страницы})`}/> раз!
    </P>
</Par>

<Par>
    <P>
        ...
    </P>
</Par>


<Heading>B-деревья</Heading>

<Par>
    <P>
        <b>B-дерево</b> порядка <Math m={`m`}/> &mdash; сильноветвящиеся дерево, у которого
    </P>
    <BulletList>
        <ListItem>у каждого узла максимум <Math m={`m`}/> детей</ListItem>
        <ListItem>у каждого узла, кроме корня и листов, минимум <Math m={`\\lceil m/2 \\rceil`}/> детей</ListItem>
        <ListItem>корневой узел, если не является листом, имеет минимум <Math m={`2`}/> ребенка</ListItem>
        <ListItem>все листья находятся на одном уровне</ListItem>
        <ListItem>любой узел с <Math m={`k`}/> детьми содержит <Math m={`k-1`}/> ключ</ListItem>
    </BulletList>
    <P>
        B-деревьев порядка <Math m={`1`}/> не бывает,
        а B-деревья порядка <Math m={`2`}/> &mdash; это простые бинарные деревья.
        Поэтому будем рассматривать только B-деревья порядка <Math m={`3`}/> и больше, <Math m={`m \\ge 3`}/>.
    </P>
</Par>

<Par>
    <P>
        Каждый узел B-дерева можно представить как массив из <Math m={`2m-1`}/> элементов.
        На нечётных позициях стоят ссылки на детей.
        На чётных позициях находятся ключи.
    </P>
    <Math display
          m={`\\Big( P_1 \\quad K_1 \\quad P_2 \\quad K_2 \\quad P_3 \\quad K_3 \\quad \\cdots \\quad P_{m-1} \\quad K_{m-1} \\quad P_m \\Big)`}/>
    <P>
        Вообще, реальный способ хранения отличается от нашего логического представления, но нам удобнее думать так.
    </P>
    <P>
        В узлах ключи упорядочены: <Math m={`K_1 < K_2 < \\dotsb < K_{m-1}`}/>,
        а каждая ссылка <Math m={`P_i`}/> указывает на узел,
        в котором все ключи находятся между ключами <Math m={`K_{i-1}`}/> и <Math m={`K_i`}/> родительского узла.
    </P>
</Par>

<Subheading>Высота B-дерева</Subheading>

<Par>
    <P>
        Ключевой характеристикой для B-дерева является высота.
        От нее зависит и временная сложность операций, и количество обращений к диску.
        Пусть в B-дереве хранится <Math m={`n`}/> ключей. Оценим высоту дерева &mdash; <Math m={`h`}/>.
    </P>
    <P>
        В корне минимум <Math m={`1`}/> ключ и минимум <Math m={`2`}/> ребёнка.
        В остальных узлах минимум <Math m={`\\lceil m/2 \\rceil - 1`}/> ключей
        и минимум <Math m={`\\lceil m/2 \\rceil`}/> детей.
        Получаем формулу для подсчёта минимального количества ключей в B-дереве высоты <Math m={`h`}/>:
    </P>
    <Math display
          m={`n_{\\mathrm{min}}(h) = 1 + 2 \\cdot n_{\\mathrm{min}}(h-1) \\implies n_{\\mathrm{min}}(h) = 2 \\cdot \\lceil m/2 \\rceil^h - 1`}/>
    <P>
        Аналогично, для максимального количества ключей
    </P>
    <Math display
          m={`n_{\\mathrm{max}}(h) = (m-1) + m \\cdot n_{\\mathrm{max}}(h) \\implies n_{\\mathrm{max}}(h) = m^{h+1} - 1`}/>
    <P>
        Тогда из общего неравенства
    </P>
    <Math display m={`2 \\cdot \\lceil m/2 \\rceil^h - 1 \\le n \\le m^{h+1} - 1`}/>
    <P>
        можно получить неравенство для высоты дерева
    </P>
    <Math display m={`\\lfloor \\log_m n \\rfloor - 1 \\le h \\le \\left\\lceil \\log_{\\lceil m/2 \\rceil} \\frac{n+1}{2} \\right\\rceil`}/>
</Par>


<Subheading>Поиск</Subheading>

<Par>
    <P>
        В целом операция поиска в B-дереве аналогична операции поиска в бинарном дереве.
    </P>
    <P>
        Пусть нам нужно найти ключ <Math m={`K`}/> в B-дереве.
        Обращаемся к диску, получаем узел и сохраняем его в оперативную память.
        Ищем в этом узле ключ <Math m={`K`}/>, или ссылку <Math m={`P_i`}/>, где <Math m={`K_{i-1} < K < K_i`}/>.
        Переходим по этой ссылке, получаем новый узел, и продолжаем наш поиск.
        Если мы дошли до листа и не нашли узел <Math m={`K`}/>, значит его в B-дереве нет.
    </P>
</Par>

<Codeblock code={
`function search(node root, key) -> node:
    ...`
}/>

<Par>
    <P>
        В целом нам потребуется максимум
    </P>
</Par>