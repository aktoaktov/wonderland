<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Link from "$lib/Elements/Link.svelte"
    import EnumList from "$lib/List/EnumList.svelte"
    import ListItem from "$lib/List/ListItem.svelte"
    import Image from "$lib/Elements/Image.svelte"
    import Proof from "$lib/Stencils/Blocks/Proof.svelte"

    import imageTrieExample from "./trie-example.svg"
</script>

<Title title="Бор"
/>

<Par>
    <P>
        Обратимся снова к поиску слова в словаре.
        Во всех нормальных словарях на правой границе написаны буквы (а в некоторых даже вырублены засечки),
        с помощью которых можно мгновенно найти место, где начинаются слова на определенную букву.
        Я однажды увидел справочник, в котором справа были вырублены первые буквы слов, а сверху &mdash; вторые.
        Таким образом в этом справочнике можно мгновенно найти блок слов по первой букве,
        а в нём подблок слов по второй букве.
        У книги три свободных стороны... теоретически, можно сделать книгу,
        в которой можно будет искать слова до третьей буквы!
    </P>
    <P>
        Эта идея очень просто обобщается, и из нее создается простая и лаконичная структура данных,
        позволяющая очень быстро искать информацию &mdash; бор.
        Задача поиска данных описанным методом называется лучевым поиском.
    </P>
</Par>

<Par>
    <P>
        <b>Задача лучевого поиска.</b>
        Есть алфавит <Math m={`\\Sigma`}/> размера <Math m={`\\sigma`}/>.
        Строки <Math m={`K_i \\in \\Sigma^*`}/> будут являться ключами, с которыми ассоциированы записи <Math
            m={`R_i`}/>.
        Нужно по заданной строке <Math m={`K_i`}/> найти ассоциированную с ней запись <Math m={`R_i`}/>.
    </P>
</Par>

<Par>
    <P>
        Будем действовать точно так же, как в тех книжках с буквенными метками. Сделаем бор.
    </P>
    <P>
        Бор &mdash; дерево, каждое ребро которого помечено символом из <Math m={`\\Sigma`}/>.
        Некоторые узлы помечены терминальными, и в них хранятся записи (или ссылки на записи).
        Вообще, бор полностью совпадает с деревом решений при поиске в словаре по буквенным меткам.
    </P>
</Par>

<Par>
    <P>
        Вот пример бора, построенного для слов
        a, an, ani, anime, ant, day, done, doc, dock, have, her, him.
    </P>
</Par>

<Image src={imageTrieExample}/>


<Subheading>Хранение</Subheading>

<Par>
    <P>
        Разберемся пока с абстрактным представлением.
        В каждом узле нам нужно хранить <Math m={`\\sigma`}/> ссылок,
        ассоциированных с символами из алфавита <Math m={`\\Sigma`}/>.
        Получается, в каждом узле нам нужно хранить ассоциативный массив размера <Math m={`\\sigma`}/>,
        ключами которого служат символы из алфавита <Math m={`\\Sigma`}/>,
        а значениями &mdash; ссылки на следующие узлы.
    </P>
    <P>
        Структура узлов получается следующая
    </P>
</Par>

<Codeblock code={
`struct node:
    assoc[char: node] children
    bool is_terminal
    some additional data if is_terminal`
}/>

<Par>
    <P>
        На каждую вершину приходится <Math m={`\\sigma`}/> ссылок, возможно пустых.
        Дополнительные данные типа ссылок на записи, флаг терминальности и прочее пока не рассматриваем.
        Получается, что бор занимает <Math m={`O(\\sigma m)`}/>, где <Math m={`m`}/> &mdash; количество узлов.
    </P>
</Par>


<Subheading>Поиск</Subheading>

<Par>
    <P>
        При поиске в боре мы повторяем те же действия, что делали бы при поиске в словаре с буквенными метками.
    </P>
    <P>
        Начиная с корня, мы выбираем ссылку на следующий узел на основе символа в искомой строке <Math m={`K`}/>.
        Заканчиваем тогда, когда закончится строка или когда нам будет некуда идти.
        Если мы дошли до конца строки <Math m={`K`}/> и в итоге попали в терминальную вершину,
        значит строка <Math m={`K`}/> в боре есть, и мы сможем вытащить ассоциированную с ней запись, если надо.
    </P>
</Par>

<Codeblock code={
`function find(node root, string key) -> node:
    i = 0
    while root != none and i < length(key):
        root = root.children[key[i]]
        i += 1

    if root == none:
        return not found
    else if root.is_terminal:
        return root
    else:
        return not found`
}/>

<Par>
    <P>
        Пусть длина искомой строки <Math m={`K`}/> равна <Math m={`l`}/>.
        Во время поиска строки <Math m={`K`}/> мы потратим
        максимум <Math m={`l`}/> переходов по ассоциированным ссылкам.
    </P>
</Par>


<Subheading>Вставка</Subheading>

<Par>
    <P>
        При вставке данных в бор мы делаем всё то же самое, что и при поиске.
        В какой-то момент узлы могут закончится, вот вставляемая строка нет.
        Тогда мы продолжаем двигаться вперед, создавая себе новые вершины на пути.
    </P>
    <P>
        В самом конце мы пометим вершину как терминальную и сохраним в ней всю нужную информацию,
        например, ссылку на запись.
    </P>
</Par>

<Codeblock code={
`function insert(node root, string key) -> node:
    for i = 0; i < length(key):
        if root.children[key[i]] == none:
            root.children[key[i]] = node()

        root = root.children[key[i]]

    root.is_terminal = true
    save some additional data at root`
}/>


<Heading>Анализ строк</Heading>

<Par>
    <P>
        Рассмотрим бор на алфавите <Math m={`\\Sigma`}/> размера <Math m={`\\sigma`}/>,
        в котором хранится <Math m={`n`}/> строк.
        Давайте проанализируем количество узлов, занимаемую бором память и смежные вопросы.
    </P>
</Par>

<Subheading>Количество ветвящихся узлов</Subheading>

<Par>
    <P>
        Каждый узел бора соответствует уникальному префиксу какой-то строки.
        При этом ветвящийся узел соответствует ситуации, когда у каких-то двух строк совпадают префиксы.
        Понятно, что совпадение здесь надо считать по наибольшему общему префиксу.
    </P>
    <P>
        С точки зрения полезного анализа (сейчас и для будущего) имеет смысл рассматривать только ветвящиеся узлы.
        Количество узлов интересно нам в первую очередь с точки зрения оценки затрат памяти.
        Как мы увидим в дальнейшем, неветвящиеся хвосты и промежуточные участки имеют маленькое влияние.
        А их еще можно сжимать, оставляя существенными только ветвящиеся узлы.
    </P>
    <P>
        Рассмотрим какой-то ветвящийся узел, у которого <Math m={`\\sigma`}/> подборов,
        в которых суммарно хранится <Math m={`n`}/> строк.
    </P>
    <P>
        Вероятность того, что <Math m={`k_1`}/> строк хранится в первом подборе,
        <Math m={`k_2`}/> строк хранится во втором подборе, ...,
        <Math m={`k_\\sigma`}/> строк хранится в <Math m={`\\sigma`}/>-м подборе,
        выражается через мультиномиальный коэффициент
    </P>
    <Math display m={`\\prob(\\cdot) = \\frac{1}{\\sigma^n} \\cdot \\binom{n}{k_1 ~ k_2 ~ \\cdots ~ k_n}`}/>
    <P>
        Зная это, можно вычислить среднее количество ветвящихся узлов бора &mdash; <Math m={`M_n`}/>.
        При этом <Math m={`M_0 = M_1 = 0`}/>, и для <Math m={`n \\ge 2`}/>

    </P>
    <Math display
          m={`M_n = 1 + \\sum_{k_1 + k_2 + \\dotsb + k_\\sigma = n} \\frac{1}{\\sigma^n} \\cdot \\binom{n}{k_1 ~ k_2 ~ \\cdots ~ k_n} \\cdot (L_{k_1} + L_{k_2} + \\dotsb + L{k_\\sigma})`}/>
    <P>
        Формула симметрична относительно перестановок <Math m={`k_i`}/>, а значит
    </P>
    <Math display
          m={`M_n = 1 + \\frac{1}{\\sigma^{n-1}} \\sum_{k=0}^n \\binom{n}{k} \\cdot (\\sigma - 1)^{n-k} \\cdot L_k`}/>
    <P>
        С помощью трюка с биномиальными преобразованиями последовательностей можно получить выражение без рекурсии
    </P>
    <Math display
          m={`M_n = \\sum_{k=2}^n \\binom{n}{k} \\cdot (-1)^k \\cdot \\frac{k-1}{\\sigma^{k-1}-1} = \\frac{n}{\\ln \\sigma} + O(1)`}/>
</Par>



<Heading>Поразрядная сортировка</Heading>

<Par>
    <P>
        Если на алфавите <Math m={`\\Sigma`}/> задан линейный порядок,
        то на <Math m={`\\Sigma^*`}/> естественным образом задаётся лексикографический порядок.
        Получается, мы можем сформулировать задачу сортировки строк из <Math m={`\\Sigma^*`}/>.
    </P>
    <P>
        Вообще, такая задача и такой подход встречаются очень часто,
        ведь большое количество данных имеют именно такую структуру.
        За примером далеко ходить не надо:
        обычные человеческие слова очень часто приходится сортировать в лексикографическом порядке.
    </P>
</Par>

<Par>
    <P>
        Итак, на алфавите <Math m={`\\Sigma`}/> задан порядок.
        А значит, в ассоциативном массиве мы можем получать ассоциированные с ключами ссылки по возрастанию.
        Если структура ассоциативного массива не предполагает извлечение колючей по порядку,
        можно предварительно отсортировать ключи, а в ассоциативный массиве брать ссылки по ключам в этом порядке.
    </P>
    <P>
        Поместим все строки, которые мы хотим отсортировать, в бор.
        А дальше просто рекурсивно ходим по бору в соответствии с заданным порядком.
    </P>
</Par>



<Heading>Цифровой бор</Heading>

<Par>
    <P>
        Возьмем алфавит из чисел <Math m={`W = \\{0, 1, 2, \\dotsc, w\\}`}/>.
        Тогда можно взять язык <Math m={`W^+ = \\NN`}/>.
        На самом деле это просто по-умному записанная фраза
        &laquo;представим все числа в системе счисления по основанию <Math m={`w`}/>
        и будем рассматривать их как строки над алфавитом <Math m={`W`}/>&raquo;.
    </P>
    <P>
        Теперь бор может хранить натуральные числа.
        Во время вставки, удаления и поиска числа <Math m={`n`}/> нам нужно сделать <Math m={`\\log_w n`}/>
        переходов по ассоциированным ссылкам.
        Получается, эти операции работают за время <Math m={`O(\\log_w n)`}/>.
    </P>
</Par>

<Par>
    <P>
        Разберем подробнее двоичную систему счисления, <Math m={`w = 2`}/>.
        Бор здесь превращается в бинарное дерево:
        левому ребенку соответствует цифра <Math m={`0`}/>, а правому <Math m={`1`}/>.
    </P>
</Par>