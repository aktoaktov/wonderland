<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
</script>

<Title title="Фильтр Блума"
/>

<Par>
<P>
    Вспомним про абстрактную структуру данных множество.
    Для её адекватной реализации в любом случае требуется достаточно много памяти.
    Мы можем попытаться ослабить это требования за счёт возможности ошибаться.
</P>
<P>
    Мы хотим создать такую структуру данных, в которую можно будет добавлять объекты
    и пытаться определять наличие в ней объектов.
    На запрос &laquo;есть ли в множестве объект <Math m={`x`}/>?&raquo; можно получить или определенный
    отрицательный ответ &laquo;объекта <Math m={`x`}/> точно нет&raquo; или неопределенный положительный ответ
    &laquo;объект <Math m={`x`}/>, возможно, в множестве есть&raquo;.
</P>
<P>
    Пусть все наши объекты &mdash; элементы какого-то универсума <Math m={`\\UUU`}/>.
</P>
<P>
    Про удаление объектов из нашей структуры пока не думаем и не говорим.
</P>
</Par>

<Par>
<P>
    Реализацией нашей идеи служит структура <b>фильтр Блума</b> (Bloom filter).
    Эта структура данных использует хеширование.
</P>
<P>
    Заведем битовый массив <Math m={`b \\in \\{0, 1\\}^m`}/>, состоящий из <Math m={`m`}/> элементов.
    Этот битовый массив будет хранить информацию о наличии и отсутствии объектов в нашем множестве.
</P>
<P>
    Создадим еще <Math m={`k`}/> независимых хеш-функций
    <Math m={`h_1, h_2, \\dotsc, h_k \\colon \\UUU \\surjto \\{1, 2, \\dotsb, m\\}`}/>.
</P>
</Par>

<Codeblock code={
`const array h[k]
array[bool] b[m]`
}/>

<Subheading>Добавление элемента</Subheading>

<Par>
<P>
    При добавлении элемента <Math m={`x`}/> в множество нужно записать <Math m={`1`}/>
    в массив <Math m={`b`}/> на каждую из позиций <Math m={`h_1(x), h_2(x), \\dotsc, h_k(x)`}/>.
</P>
</Par>

<Codeblock code={
`function add(x):
    for int i = 0; i < k:
        int index = h[i](x)
        b[index] = true`
}/>

<Par>
<P>
    Временная сложность выполнения операции &mdash; <Math m={`O(k)`}/>.
</P>
</Par>

<Subheading>Проверка наличия</Subheading>

<Par>
<P>
    Чтобы проверить, что элемент <Math m={`x`}/> принадлежит множеству, нужно проверить,
    что все биты в массиве <Math m={`b`}/> на позициях <Math m={`h_1(x), h_2(x), \\dotsc, h_k(x)`}/>
    установлены в <Math m={`1`}/>.
    Если хотя бы один бит равен <Math m={`0`}/>, то элемента <Math m={`x`}/> в множестве быть не может.
</P>
</Par>

<Codeblock code={
`function check(x) -> bool:
    bool contains = true
    for int i = 0; i < k:
        int index = h[i](x)
        contains &= b[index]

    return contains`
}/>

<Par>
<P>
    Временная сложность выполнения операции &mdash; <Math m={`O(k)`}/>.
</P>
</Par>

<Par>
<P>
    Как уже упоминалось выше, операция <Code c="check(x)"/> может вернуть или определенный отрицательный ответ,
    или неопределенный положительный.
    Из-за этого свойства фильтр Блума нельзя использовать напрямую, если важна точность.
    Но он очень сильно пригождается тогда, когда надо выполнять много дорогостоящих запросов к другой структуре.
</P>
<P>
    Например, есть у нас какая-то база данных (на самом деле любая структура данных) с дорогим доступом к элементам.
    Создадим поверх этой базы фильтр Блума, добавив в него все элементы, которые есть в базе данных.
    Теперь, когда нам приходит запрос к несуществующим данным, мы его отфильтруем фильтром Блума
    и не пустим дальше к базе данных.
    В итоге у нас значительно уменьшилось количество дорогостоящих запросов к базе данных
    ценой небольшого количества дополнительной памяти на фильтр.
</P>
</Par>


<Heading>Вероятность ошибки и её минимизация</Heading>

<Par>
<P>
    Давайте посчитаем вероятность ложного положительного срабатывания операции <Code c="check(x)"/>.
    Как и прежде, размер битового массива <Math m={`m`}/>, количество хеш-функций <Math m={`k`}/>.
    Пусть в нашем множестве уже содержится <Math m={`n`}/> элементов.
</P>
<P>
    Посчитаем вероятность того, что конкретный бит <Math m={`j`}/> не будет установлен в <Math m={`1`}/>
    хеш-функцией <Math m={`h_i`}/> при вставке очередного элемента <Math m={`x`}/>.
</P>
<Math display m={`\\prob \\big( h_i(x) \\neq j \\big) = 1 - \\frac{1}{m}`}/>

<P>
    Тогда для <Math m={`k`}/> хеш-функций вероятность того, что конкретный бит <Math m={`j`}/> не будет установлен в
    <Math m={`1`}/> равна
</P>
<Math display m={`\\prob \\big( h_i(x) \\neq j \\? \\forall i \\big) = \\left( 1 - \\frac{1}{m} \\right)^k`}/>

<P>
    Теперь можем посчитать вероятность того, что <Math m={`j`}/>-ый бит будет равен <Math m={`0`}/> после вставки <Math
        m={`n`}/> элементов в изначально пустой фильтр Блума
</P>
<Math display m={`\\prob \\big( b[j] = 0 \\big) = \\left( 1 - \\frac{1}{m} \\right)^{kn}`}/>

<P>
    Ложное положительное срабатывание <Code c="check(x)"/> происходит тогда,
    когда для несуществующего элемента <Math m={`x`}/> все <Math m={`k`}/> бит окажутся ненулевыми.
    Вероятность такого события равна
</P>
<Math display
      m={`\\prob (\\text{ложное срабатывание}) = \\Bigg( 1 - \\left( 1 - \\frac{1}{m} \\right)^{kn} \\Bigg)^k`}/>
</Par>

<Par>
<P>
    Можно вычислить оптимальное значение <Math m={`k`}/>, которое минимизирует ошибку.
    В таком виде задача минимизации не решается, придется прибегнуть к асимптотическим оценкам.
    Используя второй замечательный предел, можно упростить
</P>
<Math display m={`\\left( 1 - \\frac{1}{m} \\right)^{kn} \\approx e^{-kn/m}`}/>
<P>
    Тогда
</P>
<Math display m={`\\prob (\\text{ошибка}) \\approx \\left( 1 - e^{-kn/m} \\right)^k`}/>

<P>
    И вот уже в такой форме можно найти такое <Math m={`k`}/>, при котором вероятность ошибки минимальная.
    Достаточно прологарифмировать вероятность ошибки и найти ноль производной. В итоге получается
</P>
<Math display m={`\\argmin_k \\prob (\\text{ошибка}) \\approx \\frac{m}{n} \\cdot \\ln 2`}/>

<P>
    Подставив это значение <Math m={`k`}/> можно найти эту самую минимальную вероятность ошибки
</P>
<Math display m={`\\min \\prob (\\text{ошибка}) \\approx \\left( 1 - \\frac{1}{e} \\right) ^{m/n \\cdot \\ln 2}`}/>
</Par>