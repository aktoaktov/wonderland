<script>
    import Par from "$lib/Markup/Par.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import P from "$lib/Markup/P.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Theorem from "$lib/Stencils/Blocks/Theorem.svelte"
    import Proof from "$lib/Stencils/Blocks/Proof.svelte"
</script>

<Heading>Код Грея и бинарные строки</Heading>

<Par>
<P>
    Часто порядок генерации кортежей бывает важен.
    Разберем здесь генерацию бинарных строк таким образом, чтобы каждая следующая строка отличалась от предыдущей ровно
    в однои бите.
    Такой способ кодирования называется кодом Грея.
</P>
<P>
    Например, последовательность кодов Грея для <Math m={`n = 4`}/>
</P>
<Math display m={`\\align{
0000, \\quad 0001&, \\quad 0011, \\quad 0010, \\quad 0110, \\quad 0111, \\quad 0101, \\quad 0100, \\\\
1100, \\quad 1101&, \\quad 1111, \\quad 1110, \\quad 1010, \\quad 1011, \\quad 1001, \\quad 1000}`}/>
</Par>

<Par>
<P>
    Код Грея можно задать рекурсивно.
</P>
<P>
    Пусть <Math m={`\\Gamma_n`}/> &mdash; последовательность кодов Грея длины <Math m={`n`}/>.
    Тогда <Math m={`\\Gamma_0 = \\epsilon`}/> и
</P>
<Math display m={`\\Gamma_{n+1} = 0 \\, \\Gamma_n, ~ 1 \\, \\Gamma_n^\\R`}/>
<P>
    где <Math m={`a \\, X`}/> означает новую последовательность,
    полученную путём присоединения <Math m={`a`}/> перед всеми членами последовательности <Math m={`X`}/>,
    и <Math m={`X^\\R`}/> означает новую последовательность,
    полученную путём разворачивания всех членов последовательности <Math m={`X`}/> как строк.
</P>
<P>
    Поскольку <Math m={`\\Gamma_{n+1}`}/> начинается с <Math m={`0 \\, \\Gamma_n`}/>, то последовательность
</P>
<Math display m={`\\Gamma_\\oo = g(0),~ g(1),~ g(2),~ g(3),~ g(4),~ \\dotsc = 0,~ 1,~ 11,~ 10,~ 110,~ \\dotsc`}/>
<P>
    является перестановкой чисел <Math m={`\\NN_0`}/>, задающей коды Грея по их индексам.
</P>
</Par>

<Par>
<P>
    Последовательность кодов Грея можно определить, явно указав члены последовательности <Math m={`\\Gamma_\\oo`}/>,
    каждый член <Math m={`g(j)`}/> &mdash; код Грея с индексом <Math m={`j`}/>.
</P>
<P>
    Пусть <Math m={`j = 2^k + r`}/>, где <Math m={`0 \\le r < 2^k`}/>.
    Тогда можно воспользоваться рекуррентным соотношением и получить, что
</P>
<Math display m={`g \\bigl( 2^k + r \\bigr) = 2^k + g \\bigl( 2^k - r - 1 \\bigr)`}/>
<P>
    Отсюда можно вывести приятную формулу вычисления <Math m={`g(j)`}/>.
</P>
<P>
    Пусть двоичное представление <Math m={`j = \\bigl( \\dotsm j_2 \\, j_1 \\, j_0 \\bigr)_2`}/>,
    и двоичное представление <Math m={`g(j) = \\bigl( \\dotsm g_2 \\, g_1 \\, g_0 \\bigr)_2`}/>.
    Тогда
</P>
<Math display m={`g_k = j_k \\oplus j_{k+1} \\qquad \\text{для всех}~ k \\ge 0`}/>
<P>
    Имеет место и обратная формула
</P>
<Math display
      m={`j_k = g_k \\oplus g_{k+1} \\oplus g_{k+2} \\oplus g_{k+3} \\oplus \\dotsb
          = \\bigoplus_{i=0}^\\oo g_{k+i} \\qquad \\text{для всех}~ k \\ge 0`}/>

<P>
    С помощью этих двух формул можно получить способ
    очень легко и быстро вычислять код Грея и номер кода Грея с помощью битовой арифметики
</P>
<Math display m={`g(j) = j \\oplus \\lfloor j/2 \\rfloor`}/>
<Math display
      m={`j = g(j) \\oplus \\lfloor g(j)/2 \\rfloor \\oplus \\lfloor g(j)/4 \\rfloor \\oplus \\dotsb = \\bigoplus_{i=0}^\\oo \\left\\lfloor \\frac{g(j)}{2^i} \\right\\rfloor`}/>
<P>
    В коде ещё проще
</P>
</Par>

<Codeblock language="cpp" code={
`unsigned int to_gray_code(unsigned int n) {
    return n ^ (n >> 1);
}

unsigned int from_gray_code(unsigned int gray) {
    unsigned int n = gray;
    while (gray >>= 1) {
        n ^= gray;
    }
    return n;
}`
}/>

<Par>
<P>
    На основе кодов Грея можно сделать генератор всех битовых строк фиксированной длины,
    при этом каждую итерацию изменяться будет только один бит в выдаваемой строке.
</P>
<P>
    Нужно только понять, какой бит менять на <Math m={`k`}/>-й итерации.
</P>
<P>
    <Math m={`\\rho(k)`}/> &mdash; позиция младшего единичного бита в <Math m={`k`}/>
</P>
</Par>

<Codeblock code={
`generator binary_tuples(int n) -> tuple[bool]:
    array[bool] bits = [0, 0, ..., 0]

    yield tuple(bits)

    for int i = 1; i < 2 ** n; i++:
        change_bit = (i ^ (i >> 1)) ^ ((i-1) ^ ((i-1) >> 1))
        pos = change_bit.bit_length() - 1
        bits[pos] ^= 1
        yield tuple(bits)`
}/>


<Heading>Функции Уолша и Радемахера</Heading>

<Par>
<P>
    Здесь безумно часто будет необходимо получить конкретный бит числа. Поэтому я сразу введу обозначения
</P>
<Math display
      m={`g(k) = \\bigl( \\dotsm g_3 \\, g_2 \\, g_1 \\, g_0 \\bigr)_2 \\quad\\text{и}\\quad
          x = \\bigl( \\dotsm x_3 \\, x_2 \\, x_1 \\, x_0 \\bigr)_2`}/>
<P>
    Здесь <Math m={`x_j`}/> означает <Math m={`j`}/>-й бит числа <Math m={`x`}/>.
</P>
</Par>

<Par>
<P>
    <b>Функции Уолша</b> &mdash; функции, введенные Джозефом Леонардом Уолшем для упрощения работы
    с комбинаторными объектами и их генерации.
</P>
<Math display
      m={`w_0(x) = 1 \\quad\\text{и}\\quad
          w_k(x) = (-1)^{x \\bmod 2} \\cdot w_{\\lfloor k/2 \\rfloor} ( \\lfloor x/2 \\rfloor )
          \\quad\\text{для}~ k > 0`}/>

<P>
    Функции Уолша классически определяют как раз через код Грея и бинарную свёртку.
</P>
<Math display m={`w_k(x) = (-1) ^ {g(k) \\circledast x}`}/>

<P>
    Здесь <Math m={`g(k) \\circledast x`}/> &mdash; бинарная свёртка чисел <Math m={`g(k)`}/> и <Math m={`x`}/>:
</P>
<Math display
      m={`g(x) \\circledast x = \\sum_{j=0}^\\oo g_j \\cdot x_j`}/>

<!--<P>-->
<!--    <Math m={`w_k(0) = 1`}/> и <Math m={`w_k(x)`}/> ровно <Math m={`k`}/> раз меняет знак на <Math m={`(0, 1)`}/>,-->
<!--    приближаясь слева к <Math m={`(-1)^k`}/>. Выводится это индукцией из определяющего рекуррентного соотношения.-->
<!--    Функция получается очень похожей на <Math m={`\\cos k \\pi x`}/>.-->
<!--</P>-->
</Par>

<!--<Image src="">Графики функций <Math m={`w_k(x)`}/> и <Math m={`\\sqrt{2} \\cos k \\pi x`}/></Image>-->

<Par>
<P>
    <b>Функции Радемахера</b> &mdash; функции, предложенные Гансом Радемахером
</P>
<Math display m={`r_k(x) = (-1)^{x_k}`}/>
</Par>

<Subheading>Связь с кодами Грея</Subheading>

<Par>
<P>
    Из этих свойств можно получить важное соотношение между функциями Уолша и функциями Радемахера
</P>
<Math display
      m={`w_k(x) = \\prod_{j=0}^\\oo r_j(x)^{g_j}`}/>
<P>
    Отсюда заключаем, что кратность <Math m={`r_j(x)`}/> в <Math m={`w_k(x)`}/>
    представляет собой <Math m={`j`}/>-й бит числа <Math m={`g(k)`}/>.
    Тогда
</P>
<Math display m={`w_{k}(x) = r_{\\rho(k)+1}(x) \\cdot w_{k-1}(x) \\quad \\text{для}~ k > 0`}/>
</Par>

<Subheading>Ортогональность</Subheading>

<Par>
<P>
    И функции Уолша, и функции Радемахера ортогональны
</P>
<Math display
      m={`\\frac{1}{2^n} \\sum_{x=0}^{2^n-1} w_a(x) \\cdot w_b(x) = [a = b] \\quad\\text{и}\\quad \\frac{1}{2^n} \\sum_{x=0}^{2^n-1} r_a(x) \\cdot r_b(x) = [a = b]`}/>
</Par>

<Par>
<P>
    Функции Радемахера мультипликативны
</P>
<Math display m={`r_k^{a + b}(x) = r_k^{a \\oplus b}(x)`}/>
<P>
    Из мультипликативности функций Радемахера следует групповой закон для функций Уолша
</P>
<Math display m={`w_a(x) \\cdot w_b(x) = w_{a \\oplus b}(x)`}/>
<P>
    Вообще получается, что функции Уолша образуют абелеву группу относительно поточечного умножения.
    Из этого факта следует более слабое, но часто встречающееся свойство
    <Math m={`w_n(x) = w_{2^k}(x) \\cdot w_r(x)`}/>, где <Math m={`n = 2^k + r`}/> и <Math m={`0 \\le r < 2^k`}/>.
</P>
<P>
    А ещё, группа функций Уошла изоморфна натуральным числам с операцией побитового исключающего или
</P>
<Math display m={`\\bigl( \\{ w_k : k \\in \\N_0 \\}, \\cdot \\bigr) \\isom (\\NN_0, \\oplus) \\isom \\ZZ_2^\\oo`}/>
</Par>


<Heading>Циклы Грея</Heading>

<Par>
<P>
    Код Грея <Math m={`g(\\cdot)`}/> является только одним из множества способов обхода всех бинарных строк
    с изменением только в одном бите за шаг.
</P>
<P>
    <b>Цикл Грея</b> &mdash; последовательность бинарных строк <Math m={`v_0, v_1, v_2, \\dotsc, v_{2^n-1}`}/> такая,
    что <Math m={`v_k`}/> отличается от <Math m={`v_{(k+1) \\bmod 2^n}`}/> только в одном бите.
    Получается, что цикл Грея является гамильтоновым циклом в бинарном <Math m={`n`}/>-мерном кубе.
</P>
<P>
    Поскольку цикл Грея является гамильтоновым циклом, можно выбрать индексы так, чтобы
</P>
<Math display m={`v_0 = 000 \\dotsm 00`}/>
</Par>

<Par>
<P>
    Будем рассматривать битовые строки <Math m={`v_0, v_1, \\dotsc, v_{2^n-1}`}/> как числа,
    записанные в двоичной системе счисления.
</P>
<P>
    <b>Дельта-последовательность</b> &mdash; последовательность чисел <Math m={`\\delta_k`}/>, для которых
</P>
<Math display m={`v_{(k+1) \\bmod 2^n} = v_k \\oplus 2^{\\delta_k}`}/>
<P>
    Дельта-последовательность показывает, какие биты надо менять на каком шаге.
    Например, для обычного кода Грея <Math m={`g(\\cdot)`}/> дельта-последовательность
    определяется как <Math m={`\\delta_k = \\rho(k+1)`}/>,
    но последнее значение <Math m={`\\delta_{2^n-1} = n-1`}/>, а не <Math m={`n`}/>.
</P>
</Par>

<Theorem title="Расширение цикла Грея">
<P>
    Пусть <Math m={`\\alpha_1 \\, j_1 \\, \\alpha_2 \\, j_2 \\dotsm \\alpha_l \\, j_l`}/> &mdash;
    дельта-последовательность для <Math m={`n`}/>-битного цикла Грея, причем
    каждое <Math m={`j_k`}/> является одной координатой,
    каждое <Math m={`\\alpha_k`}/> является последовательностью координат, возможно пустой,
    и <Math m={`l`}/> нечётное. Тогда
</P>
<Math display
      m={`\\alpha_1 \\, (n+1) \\, \\alpha_1^\\R \\, n \\, \\alpha_1 \\,\\, j_1 \\,\\, \\alpha_2 \\, n \\, \\alpha_2^\\R \\, (n+1) \\alpha_2 \\,\\, j_2 \\,\\, \\alpha_3 \\, (n+1) \\, \\alpha_3^\\R \\, n \\alpha_3 \\,\\, j_3 \\,\\, \\cdots \\,\\, j_{l-1} \\,\\, \\alpha_l \\, (n+1) \\, \\alpha_l^\\R \\, n \\, \\alpha_l \\,\\, (n+1) \\, \\alpha_l^\\R \\, j_{l-1} \\, \\alpha_{l-1}^\\R \\, j_{l-2} \\, \\cdots \\, \\alpha_2^\\R \\, j_1 \\alpha_1^\\R \\, n`}/>
</Theorem>

<Subheading>Количества переходов</Subheading>
<Par>
<P>
    <b>Количества переходов</b> дельта-последовательности
    <Math m={`\\delta_0, \\delta_1, \\delta_2, \\dotsc, \\delta_{2^n-1}`}/> &mdash;
    кортеж <Math m={`(c_0, c_1, c_2, \\dotsc, c_{n-1})`}/>, в котором
</P>
<Math display m={`c_j = \\bigl( \\text{количество раз, когда}~ \\delta_k = j \\bigr)`}/>
<P>
    Количества переходов выражают частоту изменения битов с определенными номерами.
</P>
<P>
    Можно аккуратно выбрать дельта-последовательность,
    чтобы в итоге получить более-менее сбалансированные количества переходов.
</P>
</Par>

<Theorem title="Наилучшее условие сбалансированности">
<P>
    Для любого <Math m={`n`}/> существует цикл Грея с количествами переходов
    <Math m={`(c_0, c_1, c_2, \\dotsc, c_{n-1})`}/>, для которых
</P>
<Math display m={`|c_j - c_k| \\le 2 \\quad\\text{для}~ 0 \\le j < k < n`}/>
<P>
    Причём это условие сбалансированности является наилучшим.
</P>
</Theorem>

<Proof>
<Par>
<P>
    <b>Наилучшая сбалансированность.</b>
    Каждое количество переходов <Math m={`c_j`}/> должно быть чётным числом,
    и <Math m={`c_0 + c_1 + c_2 + \\dotsb + c_{n-2} + c_{n-1} = 2^n`}/>.
</P>
<P>
    Условие <Math m={`|c_j - c_k| \\le 2`}/> для <Math m={`0 \\le j < k < n`}/>
    выполняется тогда и только тогда, когда
    <Math m={`n-r`}/> количеств равны <Math m={`2q`}/> и <Math m={`r`}/> количеств равны <Math m={`2q+2`}/>,
    где <Math m={`q = \\lfloor 2^{n-1} / n \\rfloor`}/> и <Math m={`r = 2^{n-1} \\bmod n`}/>.
</P>
</Par>
</Proof>