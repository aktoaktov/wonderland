<script>
    import Heading from "$lib/Markup/Heading.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Statement from "$lib/Stencils/Blocks/Statement.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import Algorithm from "$lib/Stencils/Algorithms/Algorithm.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
</script>

<Heading>Сортировка</Heading>

<Par>
    <P>
        Пусть у нас есть <Math m="n"/> записей, которые мы хотим упорядочить
    </P>
    <Math display m={`R_1, R_2, R_3, \\dotsc, R_{n-1}, R_n`}/>
    <P>
        Каждая запись <Math m="R_i"/> имеет ключ <Math m="K_i"/>, по которому и происходит сортировка.
        Ключи можно сравнивать друг с другом. Более формально, на множестве ключей введено отношение частичного порядка
        <Math m="\le"/>.
    </P>
</Par>

<Statement title="Сортировка">
    <P>
        Задача сортировки &mdash; найти такую перестановку записей <Math m="\sigma"/>, после применения которой ключи
        расположились этих записей бы в порядке, заданным отношением <Math m="\le"/>
    </P>
    <Math display
          m={`K_{\\sigma(1)} \\le K_{\\sigma(2)} \\le K_{\\sigma(3)} \\le \\dotsb \\le K_{\\sigma(n-1)} \\le K_{\\sigma(n)} `}/>

    <P>
        Сортировка называется <b>устойчивой</b>, если записи с одинаковыми ключами остаются в изначальном
        порядке
    </P>
    <Math display
          m={`\\sigma(i) < \\sigma(j) \\quad \\text{для любых}~ K_{\\sigma(i)} = K_{\\sigma(j)} ~\\text{и}~ i < j`}/>
</Statement>

<Par>
    <P>
        Пока мы говорим только о <b>внутренней сортировке</b>. Число записей достаточно мало, и сами они невелики,
        поэтому весь процесс можно провести в оперативной памяти.
    </P>
    <P>
        В зависимости от задачи, мы будем или физически переставлять записи в памяти, или составлять дополнительную
        таблицу, представляющую перестановку.
        Если запись имеет несколько полей, то удобно составить таблицу адресных ссылок, указывающих на записи, и
        работать с ней, не перемещая тяжелые записи.
        Если ключи маленькие, а записи большие, можно добавить ключи к адресной таблице и сортировать так.
    </P>
    <P>
        Сама сортировка зависит и от структуры данных, в которой хранятся записи, и от типа самих записей.
    </P>
</Par>

<Subheading>Адресная сортировка</Subheading>

<Par>
    <P>
        Вообще, можно отсортировать набор ключей, а после переставить сами записи в нужном порядке.
    </P>
</Par>


<Heading>Пример сортировки</Heading>

<Par>
    <P>
        Посмотрим на довольно неэффективный, но показательный алгоритм сортировки.
        На этом примере мы научимся понимать, писать и анализировать алгоритмы сортировки (на самом деле не только
        сортировки).
    </P>
</Par>


<Par>
    <P>
        Нам нужно отсортировать <Math m="n"/> записей <Math m="R_1, R_2, \dotsc, R_n"/> по ключам
        <Math m="K_1, K_2, \dotsc, K_n"/>.
    </P>
    <P>
        <Math m="j"/>-й ключ в отсортированной последовательности превышает ровно <Math m="j-1"/> остальных ключей.
        Давайте сравним попарно все ключи и для каждого ключа посчитаем количество ключей его меньших.
    </P>
    <P>
        Получается, нужно сравнить <Math m="K_i"/> и <Math m="K_j"/> при <Math m="1 \le i \le n"/> и <Math
            m="1 \le j \le n "/>.
        На самом деле, нам не надо сравнивать ключ с самим собой и после сравнения ключей <Math m="K_i"/> и <Math
            m="K_j"/> сравнивать <Math m="K_j"/> и <Math m="K_i"/> не нужно.
    </P>
    <P>
        В итоге сравнивать нам надо <Math m="K_i"/> и <Math m="K_j"/> при <Math m="1 \le i \le n"/> и <Math
            m="1 \le j \lt i "/>. Получаем алгоритм
    </P>
</Par>

<Algorithm title="Подсчет сравнений" let:props>
    {#snippet input()}
        <p>
            набор из <Math m="n"/> записей <Math m="R_1, R_2, \dotsc, R_n"/> с ключами <Math m="K_1, K_2, \dotsc, K_n"/>
        </p>
    {/snippet}

    {#snippet output()}
        <p>
            перестановка <Math m="\sigma"/> размера <Math m="n"/>, для которой <Math m="\sigma(i)"/> &mdash; окончательное положение записи <Math m="R_i"/>
        </p>
    {/snippet}
</Algorithm>
