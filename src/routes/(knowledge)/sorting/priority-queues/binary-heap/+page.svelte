<script>
    import Title from "$lib/Elements/Title.svelte"
    import Par from "$lib/Markup/Par.svelte"
    import P from "$lib/Markup/P.svelte"
    import Math from "$lib/Math/Math.svelte"
    import Link from "$lib/Elements/Link.svelte"
    import Code from "$lib/Code/Code.svelte"
    import Codeblock from "$lib/Code/Codeblock.svelte"
    import Heading from "$lib/Markup/Heading.svelte"
    import Subheading from "$lib/Markup/Subheading.svelte"
    import Definition from "$lib/Stencils/Blocks/Definition.svelte"
    import Image from "$lib/Elements/Image.svelte"
    import Theorem from "$lib/Stencils/Blocks/Theorem.svelte"
    import Proof from "$lib/Stencils/Blocks/Proof.svelte"
    import EnumList from "$lib/List/EnumList.svelte"
    import ListItem from "$lib/List/ListItem.svelte"
    import BulletList from "$lib/List/BulletList.svelte"

    import imageShiftDown from "./shift-down.svg"
    import imageShiftUp from "./shift-up.svg"
    import imageHeapSpecificWay from './heap-specific-way.svg'
    import image3aryHeapExample from './3ary-heap-example.svg'
    import imageDaryHeapTime from "./dary-heap-time.svg"
</script>

<Title title="Двоичная и d-арная куча"
/>

<Par>
    <P>
        Про приоритетные очереди
    </P>
    <P>
        С помощью линейных структур нельзя реализовать эффективную приоритетную очередь.
    </P>
</Par>

<Heading>Двоичная куча</Heading>

<Par>
    <P>
        Давайте создадим бинарное дерево, в котором каждая вершина будет больше своих потомков.
        При этом, для достижения минимальной высоты <Math m={`\\lfloor \\log_2 n \\rfloor + 1`}/>,
        сделаем дерево полным.
    </P>
    <P>
        Полное бинарное дерево можно хорошо хранить в массиве <Code c="h"/> длины <Math m={`n`}/>
        (индексация, напомню, с <Math m={`0`}/>).
        Тогда у элемента с индексом <Math m={`i`}/>
        детьми являются элементы с индексами <Math m={`2i+1`}/> и <Math m={`2i+2`}/>,
        а родителем &mdash; элемент с индексом <Math m={`\\lfloor (i-1)/2 \\rfloor`}/>.
    </P>
    <P>
        По нашему построению видно, что максимальный элемент в куче имеет индекс <Math m={`0`}/>,
        а минимальный элемент находится в одном из листьев.
        А так же для всех элементов выполнено &laquo;свойство кучи&raquo;:
    </P>
    <Math display
          m={`\\code{h}[i] \\ge \\code{h} \\bigl[ \\lfloor (i-1)/2 \\rfloor \\bigr] \\quad \\text{для всех}~ i`}/>
</Par>

<Par>
    <P>
        Теперь мы можем производить какие-то операции с кучей.
        А именно, вставлять элементы, изменять элементы и извлекать минимум (про тонкости реализации позже).
    </P>
    <P>
        После изменения элементов свойство кучи может нарушиться.
        Поэтому нам надо научиться быстро восстанавливать его.
    </P>
</Par>

<Subheading>Восстановление свойства кучи</Subheading>

<Par>
    <P>
        Пусть какой-то один элемент мешает свойству кучи быть выполненным.
        Как мы увидим позже, любые операции над кучей в итоге оставляют ровно один плохой элемент.
    </P>
    <P>
        Если этот элемент слишком большой, то его надо пропихнуть вверх по куче.
        Если же он наоборот, слишком маленький, то его надо пропихнуть вниз.
        Вот эти две операции пропихивания вверх и вниз называются по-научному <b>просеиванием</b>.
    </P>
</Par>

<Par>
    <P>
        <b>Просеивание вниз</b> (shift down).
    </P>
    <EnumList>
        <ListItem>
            Если просеиваемый элемент меньше, чем его дети, то меняем его с наибольшим из его детей.
        </ListItem>
        <ListItem>
            Продолжаем его просеивать, пока он не встанет на нормальное место или пока он не станет листом.
        </ListItem>
    </EnumList>
</Par>

<Image src={imageShiftDown}/>

<Codeblock code={
`function shift_down(mutable array h, int i):
    const int n = length(h)

    while 2 * i + 1 < n:
        left = 2 * i + 1
        right = 2 * i + 2

        if right < n and h[right] > h[left]:
            j = right
        else:
            j = left

        break if h[i] >= h[j]

        swap h[i], h[j]
        i = j`
}/>

<Par>
    <P>
        Если просеиваемый вниз элемент находился на высоте <Math m={`h`}/>,
        то выполнение операции потребует не более <Math m={`h-1`}/> обменов и не более <Math m={`2h-2`}/> сравнений.
        Константа <Math m={`2`}/> вылезает потому, что сравниваем мы каждым ребенком.
    </P>
</Par>

<Par>
    <P>
        <b>Просеивание вверх</b> (shift up).
    </P>
    <EnumList>
        <ListItem>
            Если просеиваемый элемент меньше, чем его родитель, то меняем его с его родителем.
        </ListItem>
        <ListItem>
            Продолжаем его просеивать, пока он не встанет на нормальное место или пока он не станет корнем.
        </ListItem>
    </EnumList>
    <P>
        Здесь нет никаких ветвлений, в отличие от просеивания вниз, поэтому код будет более красивым
    </P>
</Par>

<Image src={imageShiftUp}/>

<Codeblock code={
`function shift_up(mutable array h, int i):
    while h[i] > h[(i - 1) / 2]:
        swap h[i], h[(i - 1) / 2]
        i = (i - 1) / 2`
}/>

<Par>
    <P>
        Обе операции работают за время <Math m={`O(\\text{высота кучи}) = O(\\log n)`}/>.
    </P>
</Par>


<Subheading>Вставка</Subheading>

<Par>
    <P>
        Вставка нового элемента в кучу происходит очень просто:
        мы добавляем в конец массива <Code c="h"/> новый элемент и просеиваем его вверх.
        После просеивания новый элемент займет корректное положение.
    </P>
</Par>

<Subheading>Извлечение максимума</Subheading>

<Par>
    <P>
        При извлечении минимума можно воспользоваться примерно тем же трюком, что и со вставкой.
        Поместим на место корня элемент <Math m={`-\\oo`}/>, который гарантированно меньше любого другого элемента.
        Теперь осталось просто просеять вниз этот элемент.
    </P>
    <P>
        Можно обойтись и без введения особого элемента, если вспомнить, что листы &mdash; наименьшие элементы в куче.
        Можно на место корня ставить не <Math m={`-\\oo`}/>, а какой-то лист, например последний.
        Эффект от просеивания этого элемента вниз будет точно таким же, как и от просеивания <Math m={`-\\oo`}/>:
        свойство кучи сохранено, максимум извлечён.
    </P>
</Par>

<Subheading>Построение кучи</Subheading>

<Par>
    <P>
        Представим, что у нас есть неупорядоченный массив, который мы хотим превратить в кучу.
        Можно действовать в лоб: создать пустую кучу и добавлять туда элементы из массива.
        Такой подход имеет временную сложность <Math m={`O(n \\log n)`}/>.
    </P>
    <P>
        Но в куче очень много беспорядков. Можно этим воспользоваться.
        Построить кучу из массива может операция heapify.
    </P>
</Par>

<Par>
    <P>
        Представим, что в исходном массиве уже записано полное бинарное дерево. Оно не удовлетворяет свойству кучи.
        Давайте просеем вниз все узлы, которые имеют хотя бы одного ребёнка.
        При этом будем просеивать снизу вверх, то есть начнем с элемента на позиции <Math m={`\\lfloor n/2 \\rfloor`}/>,
        а закончим корнем, который находится на позиции <Math m={`1`}/>.
    </P>
    <P>
        В итоге мы из массива получим нормальную кучу.
        До просеивания какого-то узла оба его поддерева удовлетворяли свойству кучи.
        После просеивания этого узла он вместе со своими поддеревьями будет образовывать кучу.
        Значит, после просеивания всех узлов у нас получится куча.
    </P>
</Par>

<Codeblock code={
`function heapify(mutable array h):
    const int n = length(h)
    
    for int i = (n-1)/2; i >= 0; i--:
        sift_down(h, i)`
}/>

<Par>
    <P>
        Время работы этой операции <Math m={`O(n)`}/>.
    </P>
    <P>
        Число вершин на высоте <Math m={`h`}/> не более <Math m={`\\lceil n / 2^h \\rceil`}/>.
        Для каждой из них будет вызвана операция просеивания вниз,
        которая потребует не более <Math m={`h`}/> обменов и не более <Math m={`2h`}/> сравнений.
        Значит, количество сравнений в операции heapify равно
    </P>
    <Math display
          m={`\\sum_{h=1}^{\\lfloor \\log_2 n \\rfloor + 1} \\Bigl\\lceil \\frac{n}{2^h} \\Bigr\\rceil \\cdot (2h-2) = 2n \\sum_{h=1}^{\\lfloor \\log_2 n \\rfloor + 1} \\frac{h-1}{2^h} = 4n + O(\\log n)`}/>
    <P>
        А количество обменов в <Math m={`2`}/> раза меньше, <Math m={`2n + O(\\log n)`}/>.
    </P>
</Par>


<Subheading>Анализ алгоритмов на куче</Subheading>

<Par>
    <P>
        Одна из самых важных характеристик кучи &mdash; размеры её поддеревьев.
        Просто так получить все значения, к сожалению нельзя.
        Проблемы возникают только из-за того, что куча &mdash; полное дерево, но не всегда абсолютно сбалансированное.
    </P>
    <P>
        В куче есть &laquo;особый путь&raquo;, соединяющий корень кучи с последним листом.
        На картинке я его отметил красным.
    </P>
</Par>

<Image src={imageHeapSpecificWay}/>

<Par>
    <P>
        Давайте все узлы, лежащие на особом пути, называть особыми.
        И поддеревья с корнями в особых узлах тоже будем называть особыми.
    </P>
    <P>
        Все неособые поддеревья являются абсолютно сбалансированными,
        значит их размер всегда равен <Math m={`2^k - 1`}/>.
        А&nbsp;количество неособых поддеревьев очень легко вычисляется:
    </P>
    <Math display
          m={`\\text{неособых деревьев размера}~ 2^k-1 ~\\text{ровно} \\left\\lfloor \\frac{n - 2^{k-1}}{2^k} \\right\\rfloor ~\\text{штук}`}/>

    <P>
        Осталось разобраться с особыми узлами.
        Пусть двоичное представление числа <Math m={`n`}/>
    </P>
    <Math display
          m={`n = \\bigl( b_{h} \\, b_{h-1} \\, b_{h-2} \\, \\dotsm \\, b_2, b_1, b_0 \\bigr)_2 \\quad \\text{где}~ h = \\lfloor \\log_2 n \\rfloor`}/>
    <P>
        Тогда размеры особых поддеревьев можно явно выразить через эти цифры.
        Напишу сверху вниз
    </P>
    <Math
            display m={`
            \\bigl( 1 \\, b_{h-1} \\, b_{h-2} \\, \\dotsm \\, b_2 \\, b_1 \\, b_0 \\bigr)_2 \\quad
            \\bigl( 1 \\, b_{h-2} \\, \\dotsm \\, b_2 \\, b_1 \\, b_0)_2 \\quad
            \\cdots \\quad
            \\bigl(1 \\, b_1 \\, b_0 \\bigr)_2 \\quad
            \\bigl( 1 \\, b_0 \\bigr)_2 \\quad
            1_2`}/>
</Par>

<Par>
    <P>
        Теперь мы можем посчитать количество всевозможных куч на <Math m={`n`}/> элементах.
        Пусть <Math m={`s_v`}/> &mdash; размер поддерева с корнем в <Math m={`v`}/>.
        Тогда всего куч
    </P>
    <Math display m={`\\frac{n!}{s_1 \\cdot s_2 \\cdot s_3 \\dotsm s_{n-1} \\cdot s_n} = n! \\bigg/ \\prod_{v} s_v `}/>
</Par>


<Heading>Пирамидальная сортировка</Heading>

<Par>
    <P>
        С помощью кучи можно реализовать прекрасный алгоритм сортировки, называемый пирамидальной сортировкой.
        Названия действительно не совпадают.
        По-русски куча это пирамида, но такое название приоритетной очереди не прижилось в профессиональных кругах.
        А сортировка, работающая с помощью кучи, по-прежнему называется пирамидальной.
        В английском языке все хорошо: структура данных heap, сортировка heap sort.
    </P>
</Par>

<Par>
    <P>
        Нам дали массив, который нужно отсортировать.
        Применим операцию heapify, превратив массив в кучу на максимум
        за <Math m={`4n + O(\\log n)`}/> сравнений и <Math m={`2n + O(\\log n)`}/> обменов.
        Затем будем извлекать максимум из кучи, пока та не кончится.
    </P>
    <P>
        Heapify работает без дополнительной памяти, а вытаскиваемый максимум помещается в самый конец массива.
        Поэтому, можно с каждой операцией извлечения максимума уменьшать логический размер массива.
        В итоге максимумы будут складываться с конца в порядке убывания, и в итоге мы получим отсортированный массив.
    </P>
</Par>

<Codeblock code={
`function heap_sort(mutable array h):
    int n = length(h)

    heapify()

    repeat n times:
        swap h[0] = h[n-1]
        n -= 1
        shift_down(0)`
}/>

<Par>
    <P>
        Если в алгоритм пирамидальной сортировки даётся случайная перестановка чисел <Math m={`(1, 2, \\dotsc, n)`}/>,
        то при heapify может равновероятно получиться любая из <Math m={`n! \\bigm/ \\prod_{v} s_v`}/> возможных куч.
    </P>
    <P>
        Построение кучи, как мы уже выяснили, требует
        <Math m={`4n + O(\\log n)`}/> сравнений и <Math m={`2n + O(\\log n)`}/> обменов.
        После этого мы <Math m={`n`}/> раз извлекаем максимум, который находится в корне,
        на высоте <Math m={`\\lfloor \\log_2 n \\rfloor + 1`}/>.
        Эта операция просто вызывает просеивание вниз, а значит требует
        <Math m={`\\lfloor \\log_2 n \\rfloor`}/> обменов и <Math m={`2 \\lfloor \\log_2 n \\rfloor`}/> сравнений.
        В итоге пирамидальная сортировка требует
    </P>
    <Math display
          m={`
          \\text{максимум} \\quad
          2 n \\lfloor \\log_2 n \\rfloor + 4n + O(\\log n) ~~\\text{сравнений}
          \\quad \\text{и} \\quad
          n \\lfloor \\log_2 n \\rfloor + 2n + O(\\log n) ~~\\text{обменов}
          `}/>
    <P>
        Огрубив, говорим, что пирамидальная сортировка работает за <Math m={`\\Theta(n \\log n)`}/>.
    </P>
</Par>


<Heading><Math m={`d`}/>-арная куча</Heading>

<Par>
    <P>
        Есть смысл рассматривать не только бинарные деревья для представления кучи, а вообще любые <Math m={`d`}/>-арные.
        Высота таких деревьев <Math m={`\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor + 1`}/>.
    </P>
    <P>
        Точно так же, как и для двоичной кучи, у <Math m={`d`}/>-арной кучи есть свойство кучи:
        значение любого узла больше значений всех его поддеревьев или, что то же самое, больше значений всех его детей.
    </P>
    <P>
        Хранить полное <Math m={`d`}/>-арное дерево можно точно так же в массиве.
        У элемента с индексом <Math m={`i`}/>
        детьми являются элементы с индексами <Math m={`di+1, d_i+2, \\dotsc, di+d`}/>,
        а родителем &mdash; элемент с индексом <Math m={`\\lfloor (i-1) / d \\rfloor`}/>.
    </P>
</Par>

<Image src={image3aryHeapExample}/>

<Par>
    <P>
        Все операции: просеивание, вставка, извлечение максимума и построение выполняются точно так же,
        как и с обычной двоичной кучей.
    </P>
    <P>
        Просеивание вверх требует максимум
        <Math m={`\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor`}/> обменов и сравнений,
        а просеивание вниз требует максимум
        <Math m={`\\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor`}/> обменов
        и максимум <Math m={`d \\bigl\\lfloor \\log_d \\bigl( n (d-1) \\bigr) \\bigr\\rfloor`}/> сравнений.
    </P>

</Par>

<Par>
    <P>
        Разберем операцию построения <Math m={`d`}/>-арной кучи с помощью heapify.
        Количество сравнений для операции heapify равно
    </P>
    <Math display
          m={`
          \\sum_{h=1}^{{\\small\\lfloor} \\log_d {\\small(} \\mathstrut n (d-1) {\\small)} {\\small\\rfloor} + 1} \\Bigl\\lceil \\frac{n}{d^h} \\Bigr\\rceil \\cdot (dh - d)
          = dn \\sum_{h=1}^{{\\small\\lfloor} \\log_d {\\small(} \\mathstrut n (d-1) {\\small)} {\\small\\rfloor} + 1} \\frac{h-1}{d^h}
          = \\frac{d^2}{(d-1)^2} \\cdot n + O(\\log_d n)
          `}/>
    <P>
        А количество обменов в <Math m={`d`}/> раз меньше, <Math m={`d / (d-1)^2 \\cdot n + O(\\log_d n)`}/>.
    </P>
</Par>

<Par>
    <P>
        То есть операции выполняются за время
    </P>
    <BulletList>
        <ListItem>
            вставка &mdash; <Math m={`O(\\log_d n)`}/>
        </ListItem>
        <ListItem>
            извлечение максимума &mdash; <Math m={`O(d \\log_d n)`}/>
        </ListItem>
        <ListItem>
            построение <Math m={`d`}/>-арной кучи &mdash; <Math m={`O(n)`}/>
        </ListItem>
    </BulletList>
</Par>

<Par>
    <P>
        При этом эффективность <Math m={`d`}/>-арной кучи сильно растёт только при маленьких <Math m={`d`}/>.
        Посмотрите на график зависимости числа сравнений <Math m={`\\log_d \\bigr( n (d-1) \\bigr)`}/> при вставке
        от размера кучи <Math m={`n`}/>.
        Разными цветами обозначены графики для разных значений <Math m={`d`}/>:
        от синего при <Math m={`d=2`}/> до красного при <Math m={`d=20`}/>.
    </P>
</Par>

<Image src={imageDaryHeapTime}/>